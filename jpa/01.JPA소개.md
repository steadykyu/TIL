## 글 기준 방식
1. 목차,강의 의 핵심 내용
2. 기술을 사용하는 이유, 어떻게 활용하는지(why, how)
3. 이해가 안되거나 하는 부분을 내가 이해하는 선으로.(weakness)

## 목차

## 1. 강좌 소개
+ 책을 참고서느낌으로 챙겨보고, 아래 두가지는 꼭 염두하고 공부하자.
1. 객체와 테이블을 알맞게 설정시키고 매핑하는법을 모르면 오히려 시간낭비가 될 수 있다.
2. jpa 내부 동작방식을 이해해야 시간낭비없이 sql에 시간낭비를 줄일 수 있다.

## 2. SQL 중심적인 개발의 문제점
### 1.객체 CRUD(create, read, update, and delete) 과정에서 무한 반복적이고 지루한 코드만 쳐야하는 상황이 나온다.
### 2.객체에 필드 하나만 추가하더라도 모든 DB에 또 column을 추가해주어야 한다. 결국 SQL에 의존적인 개발을 피하기 어렵다.
### 3.객체지향언어인 Java와 보관하려는 사상을 가진 RDBMS는 사상부터 다르다.
> 객체지향언어 vs RDBMS
```
상속성, 추상화, 캡슐화, 다형성 vs 값 보관에 최우선
```

### 객체 와 RDBMS 의 차이(pt그림참고)
### 1. 상속
```
객체 상속과 가장비슷한 슈퍼타입과 서브타입의 관계를 보자.
DBMS는 상속관계가 없기때문에, 슈퍼테이블과 서브테이블의 외부 pk를 조인한 값을 가져와야 한다. -> 복잡
자바는 컬렉션을 통해 add(albumId), get(albumId), Item item = list.get(albumId);(다형성) 등 상속관계를 활용할 수 있다.
```
### 2. 연관관계
```
객체는 참조를 사용한다. member.getTeam()
테이블은 외래키를 사용한다. JOIN ON M.TEAM_ID = T.TEAM_ID
테이블의 연관관계에 맞추면서, 객체지향적인 설계를 진행하여 객체모델링을 DB에 넣으려고 하면 조회, 추가등 여러 작업에 대하여 코드 작업이 너무 늘어난다.
자바컬렉션으로 하면 간단한 기능들인데 DB에 넣는다는 과정하나때문에 코드 작업이 너무 증가한다.
```
### 3. 데이터 타입
### 4. 데이터 식별 방법
#### 객체 그래프 탐색
+ 객체는 자유롭게 객체 그래프를 탐색할 수 있어야한다. 
+ 그러나 실행하는 SQL에 따라 탐색 범위가 결정되어버린다.
```
SELECT M.*, T.*
 FROM MEMBER M
 JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID 
 
 이라면
 member.getTeam();  //이건 얻을 수 있으나,
 member.getOrder(); //를 얻을 수가 없다.
```
#### 엔티티 신뢰 문제
```
public void process() {
 Member member = memberDAO.find(memberId);
 member.getTeam(); //???
 member.getOrder().getDelivery(); // ???
 }
```
+ memberDAO의 find가 어떤 SQL방식으로 찾아와서 member에 넣는지 알수 없다.
+ 즉 RDB랑 연결되면 DB를 까보지 않는이상 신뢰할수 없다.

#### 모든 객체를 미리 로딩할 수는 없다
+ 미리 로딩할수 없기때문에, 객체들에 대하여 전부다 메서드를 그리고 join query도 만들어주어야한다.
```
memberDAO.getMember(); //Member만 조회
memberDAO.getMemberWithTeam();//Member와 Team 조회
//Member,Order,Delivery 조회 
memberDAO.getMemberWithOrderWithDelivery();
```

### 계층형 아키텍처-진정한 의미의 계층 분할이 어렵다.
> 비교하기
```
String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);
member1 == member2; //다르다.
class MemberDAO {
 
 public Member getMember(String memberId) {
 String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
 ...
 //JDBC API, SQL 실행
 return new Member(...);
 }
}
```
이 경우에는 새로운 객체를 리턴했으므로 서로 다르게 나온다.
> 비교하기 - 자바컬렉션에서 조회
```
String memberId = "100";
Member member1 = list.get(memberId);
Member member2 = list.get(memberId);
member1 == member2; //같다.
``` 
이 경우에는 값에대하여 참조하고 있는것이기 때문에 같다.

## 3.JPA소개
### ORM
+ Object-relational mapping(객체 관계 매핑)
+ 객체는 객체대로 설계하고, 관계형 데이터베이스는 관계형 데이터베이스대로 설계한다. 그리고 ORM 프레임워크가 중간에서 매핑한다.
+ 저장 조회 그림 확인해보기.

### JPA를 그렇다면 왜 사용해야하는가?
- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성(코드가 줄어든다)
- 유지보수(필드만 추가하면 됨, SQL은 JPA가 처리)
- 패러다임의 불일치 해결
- 성능
- 데이터 접근 추상화와 벤더 독립성
- 표준

### 패러다임의 불일치 해결
+ 상속(저장,조회기능)
+ 연관관계, 객체 그래프 탐색
+ 신뢰할수 있는 엔티티, 계층
+ JPA와 비교하기( 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장)

### 성능
#### 1. 1차 캐시와 동일성(identity) 보장
+ 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상
+ DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장 (DB쪽 어려운 내용이라 나중에 이해하자)
#### 2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
> INSERT
```
트랜잭션을 커밋할 때까지 INSERT SQL을 모음 (persist메서드사용)
JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
```
> UPDATE
```
(객체의 값을 수정하면)
1. UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화
2. 트랜잭션 커밋 시 자동으로 UPDATE, DELETE SQL 실행하고, 바로 커밋
```
#### 3. 지연 로딩(Lazy Loading)
+ 지연 로딩: 객체가 실제 사용될 때 로딩
+ 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회(옵션입력시 사용가능)
