## 글 기준 방식
1. 목차,강의 의 핵심 내용
2. 기술을 사용하는 이유, 어떻게 활용하는지(why, how)
3. 이해가 안되거나 하는 부분을 내가 이해하는 선으로.(weakness)

## 목차


## 프로젝트 생성
+ h2 데이터베이스로 진행한다.
+ 메이븐으로 진행한다.
+ pt 보고 여러 설정 맞추기.
+ 라이브러리 추가 ( hibernate, h2database ) - 관련 라이브러리 들도 함께 설치된다.
### JPA 설정하기 
+ JPA 설정 파일 persistence.xml를 추가해준다.
+ META-INF/persistence.xml 꼭 이 위치에 만들어 주어야한다.
+ javax.persistence - 자바표준에서 제공하는 persistence
```xml
<?xml version="1.0" encoding="UTF-8"?> 
<persistence version="2.2" 
           xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"> 
      <persistence-unit name="hello"> 
           <properties> 
           <!-- 필수 속성 --> 
           <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/> 
           <property name="javax.persistence.jdbc.user" value="sa"/> 
           <property name="javax.persistence.jdbc.password" value=""/> 
           <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/> 
           <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/> 

           <!-- 옵션 --> 
           <property name="hibernate.show_sql" value="true"/> 
           <property name="hibernate.format_sql" value="true"/> 
           <property name="hibernate.use_sql_comments" value="true"/> 
           <!--<property name="hibernate.hbm2ddl.auto" value="create" />--> 
           </properties> 
       </persistence-unit> 
</persistence> 
```
+ 필수 속성은 우리의 h2database의 설정값으로, 만든 db와 일치해야한다.
+ 옵션은 아래 내용에 나오니 내려가자.

### 데이터베이스 방언
+ 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르지만, JPA는 특정 데이터베이스에 **종속되지 않는다.**
+ 방언 : SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능
ex) MySQLDialect, OracleDialect, H2Dialect 등 으로 우리는 H2Dialect를 사용한다.

## 애플리케이션개발
1. Persistence가 META-INF/persistence.xml 에서 설정정보를 조회한다.
2. Persistence가 EntityManagerFactory(emf) 생성한다.
3. emf에서 EntityManager를 요청에 따라 만들고 작업후 종료시킨다.

### 객체와 테이블을 생성하고 매핑하기.
```
create table Member ( 
 id bigint not null, 
 name varchar(255), 
 primary key (id) 
);
```
```java
  @Entity 
  public class Member { 
     @Id 
     private Long id; 
     private String name; 
     //Getter, Setter … 
}
```
+ @Entity : JPA가 관리할 객체
+ @Id: 데이터베이스 PK와 매핑

### 회원 저장기능을 해보자.
> 엔티티 팩토리를 만들고 엔티티 매니저 만들기.
```java
public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager(); 
        
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        (데이터 조회, 변경 등 
        작업들.....)
        tx.commit();
        em.close();
        emf.close();
```
+ emp는 App로딩시점에 딱 하나만 필요하다.
+ em 은 고객이 들어와서 행위를 하고 나가는(ex) 장바구니를 담고 나갔다)
+ 이런 DB커넥션을 얻어 쿼리를 내보내고 종료하는 일관적인 단위를 할때마다 생성과 종료의 작업을 가진다.
+ 데이터 조회에는 EntityTransaction(트랜잭션)이 필요가 없으나, 데이터의 변경이 일어나는 경우에는 **꼭 트랜잭션** 안에서 해야한다.
> 회원 등록하기.
```
            Member member1 = new Member();
            member1.setId(1L);
            member1.setName("HelloA");
            em.persist(member1);

            Member member2 = new Member();
            member2.setId(2L);
            member2.setName("HelloB");
            em.persist(member2);
```
+ 모든 JPA에서는 꼭 트랜잭션이라는 단위가 중요하다. 데이터를 변경하는 모든작업은 JPA가 트랜잭션 안에서 작업을 해야한다.
+ persist는 객체값을 DB에 저장한다.
+ 그리고 콘솔창을 보면 JPA가 사용한 쿼리 입력문이 나온다. 이 옵션을 설정하는 곳이 아까 입력한 Persistence.xml이다. 
```
<property name="hibernate.show_sql" value="true"/>
<property name="hibernate.format_sql" value="true"/>
<property name="hibernate.use_sql_comments" value="true"/>
```
+ 만약 다른 Table에 회원을 등록하고 싶다면 어떻게 할까?
```
@Entity
@Table(name = "USER")
public class Member {
    @Id
    private Long id;
    @Column(name = "username")
    private String name;
```
+ @Table(name = "USER")을 통해 만약 USER TABLE이 존재한다면, 맴버객체와 USER TABLE을 매핑될 것이다.
+ @Column(name = "username")은 Table Column이름을 지정해줄 수 있다.

#### 정석적인 방법으로 DB에 넣어주기
```
EntityTransaction tx = em.getTransaction();
        tx.begin();
        try{
//          회원등록기능
            Member member1 = new Member();
            member1.setId(1L);
            member1.setName("HelloA");
            em.persist(member1);

            Member member2 = new Member();
            member2.setId(2L);
            member2.setName("HelloB");
            em.persist(member2);
             tx.commit();
        } catch (Exception e){
            tx.rollback();
        } finally{
            em.close();
        }
       emf.close();
```
+ 지금은 문제없이 작동하지만, 만약 try내용중 DB와의 작업이 잘못되면 아래 부분이 실행되지 않는 참사가 일어날 것이다.
+ 엔티티매니저는 꼭 닫아주어야 하기 때문에, 다음과 같이 try catch문으로 작성해주어야 한다.
+ 이런 방식이 정석적인 부분이나, 스프링이 이 기능을 제공하고 있기때문에 알고만 있자.
+ 엔티티 매니저를 마치 자바의 컬렉션처럼 이해하면 편한다. 내 객체를 대신 저장해주는 라이브러리인것이다.
****
### 회원 삭제하기, 수정하기
```
 Member findmember = em.find(Member.class, 1L);
 //em.remove(findmember); // 삭제하기. - Delete문 수행
 findmember.setName("HelloJPA"); // 수정하기. UPDATE문 수행
 tx.commit();
```
+ 삭제는 실행은 안하고 수정하기만 실행하자.
+ 그런데 수행한경우에 em.persist() 즉 저장코드를 돌리지 않고 트랜잭션을 커밋만 해도 DB에서 값이 수정된다.
```
JPA에게 관리 받는 Entitiy는 트랜잭션이 commit하는 시점에 변경점이 없는지 확인한다.
변경점이 있다면 UPDATE문을 수행하고 트랜잭션을 커밋하기때문에, persist(Member)문없이 DB값이 수정된것이다.
```
### 회원 조회하기.
```
          Member findmember = em.find(Member.class, 1L);
          System.out.println("findmember.getId() = " + findmember.getId());
          System.out.println("findmember.getName() = " + findmember.getName());
```
+ 그런데 조금 아쉽다.
+ 18살 이상을 모두 출력하거나, id값이 2이상 등 조건에 부합하는 모든 객체를 꺼내고 싶을때는 어떻게 할까?

### JPQL 사용하기
> JPQL 왜 필요할까?
```
JPA를 사용하면 엔티티 객체를 중심으로 개발
검색(em.find)을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능(비효율)
(그러나 Table 기준의 RDBMS를 하게되면 너무 의존하게 되므로, 다른 SQL이 필요하다.)
결국 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요

```
> JPQL
```
JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어
SQL과 문법 유사
JPQL은 엔티티 객체를 대상으로 쿼리 <-> SQL은 데이터베이스 테이블을 대상으로 쿼리
```
```java
EntityTransaction tx = em.getTransaction();
tx.begin();
 List<Member> result = em.createQuery("select m from Member as m", Member.class)
//                    .setFirstResult(5)
//                    .setMaxResults(8)
                    .getResultList();
            for( Member member : result){
                System.out.println("member.Name = " + member.getName());
            }
            
            tx.commit();
```
+ 객체를 대상으로 검색하는 객체 지향 쿼리 이므로, 위의 m은 Member entitiy객체인 것이다.
+ 이 점이 앞으로 배우게될 여러 방식에서 객체지향을 도와주는데 메리트를 준다.
+ 쿼리안에는 where문, having등 여러 SQL 문법에 맞추어 조건에 부합하는 객체들을 가져올 수 있다.
+ SQL을 추상화해서 특정 데이터베이스 SQL에 의존X 
```
setFirstResult, setMaxResults는 em의 메소드 이지만, 이 안의 쿼리내용은 DB방언에 맞추어 들어간다.
그러므로 JPQL의 코드를 변경할 필요없이 원하는 결과를 얻는것이다.(다형성)
```
