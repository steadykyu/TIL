## 공부내용 요약



## 1.영속성 컨텍스트1
### JPA에서 가장 중요한 2가지
1. 객체와 관계형데이터 베이스 매핑하기(이전까지 우리가 배운것)
```
정적인 매핑과정
```
2. 영속성 컨텍스트
```
실제 내부에서 돌아가는 방식
```
### 영속성 컨텍스트
```
EntityManager.persist(entity); 
```
+ entity를 영속성 컨텍스트에 영속화(저장)한다는 의미
+ 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

### J2SE환경과 J2EE, 스프링 프레임워크 같은 컨테이너 환경
J2SE : 엔티티 매니저와 영속성 컨텍스트가 1:1
J2EE, 스프링 프레임워크 : 엔티티 매니저와 영속성 컨텍스트가 N:1
+ 고객 요청 하나당 엔티티 매니저를 하나 만들어서 작업한다.
+ 일단 이정도만 알고 넘어가자.

### 영속성 생명주기
1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
2. 영속 : 영속성 컨텍스트에 관리되는 상태
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 : 삭제된 상태
> (pt 그림 참고)
> 코드 및 코드결과로 확인해보기

### 영속성 컨텍스트의 이점
1. 1차 캐시 
2. 동일성(identity) 보장 
3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 
4. 변경 감지(Dirty Checking) 
5. 지연 로딩(Lazy Loading)

## 2.영속성 컨텍스트2

### 1차 캐시
+ 영속성 컨텍스트에 key(@id 지정해둔 변수)와 엔티티를 등록해있는 상태라면, 조회시 key값을 통해 1차캐시에서 값을 찾아온다.
+ 그러므로 값을 조회했는데 영속성 컨텍스트에 존재하지 않는 경우라면, DB에서 조회후 1차캐시에 저장후 값을 반환한다.
```java
Member findMember1 = em.find(Member.class, 101L);
Member findMember2 = em.find(Member.class, 101L);
```
+ 조회기능과 console에 커미널이 나오는 여부로 확인해보기.
### 영속 엔티티의 동일성 보장
+ 영속성 컨텍스트안의 영속 엔티티는 다른 참조변수로 값을 가져오더라도 같은 주소값을 가지고 있다.(마치 자바의 컬렉션(list)와 같다.)
+ list안의 값을 참조변수 a에 넣으나 b에 넣으나 가리키는 주소값이 같은 것처럼 영속 엔티티도 마찬가지다.
```
System.out.println("result = " + (findMember1 == findMember2));
```
+ true 값이 출력됨

### 엔티티등록-트랜잭션을 지원하는 쓰기지연
+ 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야한다.
+ persist로 엔티티 값을 영속 컨텍스트안에 등록해도, 바로 DB에 값을 저장하지 않는다.
+ 등록하는 Insert 쿼리문은 쓰기 지연 SQL 저장소에 차곡차곡 보관되어 있다가, 트랜잭션을 commit하는 순간 DB에 쿼리문을 보낸다.
+ 이렇게 함으로써 버퍼링기능(버퍼같은곳에 한번에 모았다가, 쿼리 내보내기)을 이용하거나, DB에 값을 저장하는 방식을 최적화 시킬 수있다.

### 엔티티 수정
```
Member member = em.find(Member.class,150L);
member.setName("ZZZZZZ");
tx.commit();
```
+ 이 코드만으로도 엔티티뿐만 아니라 DB의 값까지 수정된다. 왜일까?
> 변경감지 기능(Dirty Checking)
```
commit(entity) 호출시
1. flush()가 동작한다.
2. 엔티티와 스냅샷 비교
  - 스냅샷 : set등으로 엔티티에 값을 넣어주던, DB에서 꺼내오던간에 최초로 영속성 컨텍스트에 값을 읽어온 시점의 값을 저장한 것
3. Updat SQL 생성
  - 엔티티와 스냅샷이 다를경우에 Update SQL 생성후 쓰기 지연 SQL 저장소로 보냄.
4. 쓰기 지연에 있는 Update문을 flush후(DB에 적용 후) commit 함
```
+ flush 는 아래에서 좀 더 자세하게 설명

### 엔티티 삭제
+ 동작방식이 변경감지와 같다.
+ commit 시점에 update가 아닌 delete 쿼리가 나가는것 뿐이다.

## 3.플러시
+ 영속성 컨텍스트의 수정사항을 DB에 반영시키는것
### 플러시 발생
+ 변경 감지 
+ 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 
+ 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)

## 영속성 컨텍스트를 플러시하는 방법
+ em.flush() - 직접 호출 
```
커밋 이전에 쿼리를 바로 DB에 반영해버린다.
flush는 쌓인 쓰기지연 SQL를 돌려 DB에 반영할뿐, 1차캐시에는 영향을 주지 않는다.(즉 commit전까지 캐시에는 값이 남아있다.)
```
+ 트랜잭션 커밋 - 플러시 자동 호출 
+ JPQL 쿼리 실행 - 플러시 자동 호출
```
JPQL전에는 자동으로 flush를 호출해, DB에 값을 넣고 수정된 DB에서 가져온다.
(이 과정이 있어야 자연스럽게 꺼내올수 있으니까!)
```
### 플러시 모드 옵션
```
em.setFlushMode(FlushModeType.COMMIT)
FlushModeType.AUTO
 - 커밋이나 쿼리를 실행할 때 플러시 (기본값) 
FlushModeType.COMMIT
 - 커밋할 때만 플러시
```
+ 이왕이면 기본값을 쓰는게 좋다.

### 플러시 특징
+ 영속성 컨텍스트를 비우지 않음 
+ 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 
+ 실제 업무는 트랜잭션이라는 작업 단위가 중요 -> (자동으로든, 수동으로든)커밋 직전에만 동기화하면 됨

## 4.준영속상태
+ 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 
+ 영속성 컨텍스트가 제공하는 기능을 사용 못함

### 준영속 상태로 만드는 방법
+ em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
+ em.clear() : 영속성 컨텍스트를 완전히 초기화
+ em.close() : 영속성 컨텍스트를 종료

### 참고
```
실제에서는 트랙잭션단위로 작업을하기에, 우리가 이번과정에 배운것은 동기화 이슈가 발생할 일은 거의 없다.
더 큰 범위인 트랜잭션을 종료할때 저절로 영속성컨테이너도 종료되기 때문이다.
```
