## 공부내용 요약
```
3. 엔티티 - 영속성 컨테이너 - 쓰기지연 SQL - DB 로 구성되어 있다.
회원 등록, 조회, 수정, 삭제, flush(), commit(), 준영속상태들로 영속성 컨테이너의 내부 동작 방식을 알 수 있었다.
```

## 1.영속성 컨텍스트1
### JPA에서 가장 중요한 2가지
1. 객체와 관계형데이터 베이스 매핑하기(이전까지 우리가 배운것)
```
정적인 매핑과정
```
2. 영속성 컨텍스트
```
실제 내부에서 돌아가는 방식
```
### 영속성 컨텍스트
```
EntityManager.persist(entity); 
```
+ entity를 영속성 컨텍스트에 영속화(저장)한다는 의미
+ 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

### J2SE환경과 J2EE, 스프링 프레임워크 같은 컨테이너 환경
+ J2SE : 엔티티 매니저와 영속성 컨텍스트가 1:1
+ J2EE, 스프링 프레임워크 : 엔티티 매니저와 영속성 컨텍스트가 N:1
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_1.png" width="60%" height="60%">
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_2.png" width="60%" height="60%">

+ 고객 요청 하나당 엔티티 매니저를 하나 만들어서 작업한다.
+ 일단 이정도만 알고 넘어가자.

### 영속성 생명주기
1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
2. 영속 : 영속성 컨텍스트에 관리되는 상태
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 : 삭제된 상태
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_3.png" width="60%" height="60%">

> 더 디테일하게 원하면 코드로 확인해보기

### 영속성 컨텍스트의 이점
1. 1차 캐시 
2. 동일성(identity) 보장 
3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 
4. 변경 감지(Dirty Checking) 
5. 지연 로딩(Lazy Loading)

## 2.영속성 컨텍스트2

### 1차 캐시
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_4.png" width="60%" height="60%">

+ 영속성 컨텍스트에 key(@id 지정해둔 변수)와 엔티티를 등록해있는 상태라면, 조회시 key값을 통해 1차캐시에서 값을 찾아온다.
+ 그러므로 값을 조회했는데 영속성 컨텍스트에 존재하지 않는 경우라면, DB에서 조회후 1차캐시에 저장후 값을 반환한다.
```java
Member findMember1 = em.find(Member.class, 101L);
Member findMember2 = em.find(Member.class, 101L);
```
> 결과

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
result = true
```

+ 쿼리가 한개이다.-> findMember1은 DB에서 쿼리에서 통해 값을 찾고, findMember2는 영속 컨텍스트 안의 캐시에서 값을 찾음

### 영속 엔티티의 동일성 보장
+ 영속성 컨텍스트안의 영속 엔티티는 다른 참조변수로 값을 가져오더라도 같은 주소값을 가지고 있다.(마치 자바의 컬렉션(list)와 같다.)
+ list안의 값을 참조변수 a에 넣으나 b에 넣으나 가리키는 주소값이 같은 것처럼 영속 엔티티도 마찬가지다.
```
System.out.println("result = " + (findMember1 == findMember2));
```
+ result = true => true 값이 출력됨

### 엔티티등록-트랜잭션을 지원하는 쓰기지연
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_5.png" width="70%" height="70%">
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_6.png" width="70%" height="70%">

```java
            Member member1 = new Member(150L,"A");
            Member member2 = new Member(160L,"B");

            em.persist(member1);
            em.persist(member2);
            System.out.println("=========================");
            tx.commit();
```
> 결과 쓰기지연 sql에 한번에 모아서 커밋할때 쿼리를 보낸다.
```
=========================
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)

```
+ persist로 엔티티 값을 영속 컨텍스트안에 등록해도, 바로 DB에 값을 저장하지 않는다.
+ 등록하는 Insert 쿼리문은 쓰기 지연 SQL 저장소에 차곡차곡 보관되어 있다가, 트랜잭션을 commit하는 순간 DB에 쿼리문을 보낸다.
+ 이렇게 함으로써 버퍼링기능(버퍼같은곳에 한번에 모았다가, 쿼리 내보내기)을 이용하거나, DB에 값을 저장하는 방식을 최적화 시킬 수있다.

### 엔티티 수정
```
Member member = em.find(Member.class,150L);
member.setName("ZZZZZZ");
tx.commit();
```
+ 이 코드만으로도 엔티티뿐만 아니라 DB의 값까지 수정된다. 왜일까?
<img src ="https://github.com/steadykyu/TIL/blob/master/jpa/image/3_7.png" width="70%" height="70%">

> 변경감지 기능(Dirty Checking)
```
commit(entity) 호출시
1. flush()가 동작한다.
2. 엔티티와 스냅샷 비교
  - 스냅샷 : set등으로 엔티티에 값을 넣어주던, DB에서 꺼내오던간에 최초로 영속성 컨텍스트에 값을 읽어온 시점의 값을 저장한 것
3. Updat SQL 생성
  - 엔티티와 스냅샷이 다를경우에 Update SQL 생성후 쓰기 지연 SQL 저장소로 보냄.
4. 쓰기 지연에 있는 Update문을 flush후(DB에 적용 후) commit 함
```
+ flush 는 아래에서 좀 더 자세하게 설명

### 엔티티 삭제
+ 동작방식이 변경감지와 같다.
+ commit 시점에 update가 아닌 delete 쿼리가 나가는것 뿐이다.

## 3.플러시
+ 영속성 컨텍스트의 수정사항을 DB에 반영시키는것
### 플러시 발생
+ 변경 감지 
+ 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 
+ 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)

## 영속성 컨텍스트를 플러시하는 방법
+ em.flush() - 직접 호출 
```
커밋 이전에 쿼리를 바로 DB에 반영해버린다.
flush는 쌓인 쓰기지연 SQL를 돌려 DB에 반영할뿐, 1차캐시에는 영향을 주지 않는다.(즉 commit전까지 캐시에는 값이 남아있다.)
```
```
//--------------------------------플러시하는법 ----------
            Member member = new Member(200L,"member200");
            em.persist(member);

            em.flush();

            System.out.println("===================");
            tx.commit();
//커밋 이전에 쿼리를 바로 DB에 반영해버린다. 강제 호출!
```
```
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
===================
```
+ 결과값 : 커밋 이전에 쿼리를 바로 DB에 반영해버린다.
+ 트랜잭션 커밋 - 플러시 자동 호출 
+ JPQL 쿼리 실행 - 플러시 자동 호출
```
JPQL전에는 자동으로 flush를 호출해, DB에 값을 넣고 수정된 DB에서 가져온다.
(이 과정이 있어야 자연스럽게 꺼내올수 있으니까!)
```
### 플러시 모드 옵션
```
em.setFlushMode(FlushModeType.COMMIT)

- FlushModeType.AUTO
 - 커밋이나 쿼리를 실행할 때 플러시 (기본값) 
- FlushModeType.COMMIT
 - 커밋할 때만 플러시
```
+ 이왕이면 기본값을 쓰는게 좋다.

### 플러시 특징
+ 영속성 컨텍스트를 비우지 않음 
+ 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 
+ 실제 업무는 트랜잭션이라는 작업 단위가 중요 -> (자동으로든, 수동으로든)커밋 직전에만 동기화하면 됨

## 4.준영속상태
+ 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 
+ 영속성 컨텍스트가 제공하는 기능을 사용 못함

### 준영속 상태로 만드는 방법
+ em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
+ em.clear() : 영속성 컨텍스트를 완전히 초기화
+ em.close() : 영속성 컨텍스트를 종료
```java
            Member member = em.find(Member.class,150L);
            member.setName("AAAAA");
//---------------------------준영속상태로만들기
//            em.detach(member); 
// JPA에서 관리를 하지않는다.
// 엔티티값을 변경했는데 update문이 날라가지 않는다.(준영속상태가 되어, 영속성컨테이너가 관리하지 않기 때문이다.)
            
//----------------------------- 영속성 컨테이너 다 지우기
            em.clear();
            Member member2 = em.find(Member.class,150L);
            //member2를 1차캐시에서 찾아오는 것이 아니라, DB에서 값을 빼온후 다시 영속성 컨테이너에 등록한다.
            
//---------------------------- 영속성 컨테이너 닫기
//            em.close();
//            System.out.println("===================");
//            tx.commit();
```
```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
```
em.clear(); 결과값

### 참고
```
실제에서는 트랙잭션단위로 작업을하기에, 우리가 이번과정에 배운것은 동기화 이슈가 발생할 일은 거의 없다.
더 큰 범위인 트랜잭션을 종료할때 저절로 영속성컨테이너도 종료되기 때문이다.
```
