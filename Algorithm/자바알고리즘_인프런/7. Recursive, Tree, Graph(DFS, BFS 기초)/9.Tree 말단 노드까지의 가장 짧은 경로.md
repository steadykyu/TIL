## 설명
1. 최단거리이므로 사실 BFS 문제이다. 그래도 DFS로 풀어보자.

2. 

<img src ="https://github.com/steadykyu/TIL/blob/master/Algorithm/%EC%9E%90%EB%B0%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%9D%B8%ED%94%84%EB%9F%B0/7.%20Recursive%2C%20Tree%2C%20Graph(DFS%2C%20BFS%20%EA%B8%B0%EC%B4%88)/img/7_9_1.png" width="50%" height="50%">

<img src ="https://github.com/steadykyu/TIL/blob/master/Algorithm/%EC%9E%90%EB%B0%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%9D%B8%ED%94%84%EB%9F%B0/7.%20Recursive%2C%20Tree%2C%20Graph(DFS%2C%20BFS%20%EA%B8%B0%EC%B4%88)/img/7_9_2.jpg" width="50%" height="50%">

## 구현

root는 Main에서 사용하기 위해 Main 안에 인스턴스 변수로 생성한듯 하다.

1. 말단 노드는 lt와 rt가 모두 null인 node를 의미한다. 

2. 
```java
class Node{
    int data;
    Node lt, rt;
    public Node(int val){
        data=val;
        lt=rt=null;
    }
}
public class Main {
    Node root;

    int minL = 100;
    public int DFS(int L, Node root){
        if(root.lt==null && root.rt==null) return L;
        else return Math.min(DFS(L+1, root.lt), DFS(L+1, root.rt));
    }

    public static void main(String[] args){
        Main tree = new Main();
        tree.root = new Node(1);
        tree.root.lt = new Node(2);
        tree.root.rt = new Node(3);
        tree.root.lt.lt = new Node(4);
        tree.root.lt.rt = new Node(5);
        System.out.println(tree.DFS(0, tree.root));
    }
}
```

이 풀이는 만약 300의 값을 가진 node가 하나의 node만 가지고 있다면, lt,rt가 모두 null인 경우가 없으므로 에러가 발생한다. DFS 방식으로는 이 문제를 해결하기 매우 힘들다. 그러므로 역시 최단거리는 BFS를 활용하여 풀어보자.