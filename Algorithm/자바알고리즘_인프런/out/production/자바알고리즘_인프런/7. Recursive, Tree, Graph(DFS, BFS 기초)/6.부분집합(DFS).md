```java
import java.util.*;
class Main {
	static int n;
	static int[] ch;
	public void DFS(int L){
		if(L==n+1){
			 //종착지점 일떄
			String tmp="";
			for(int i=1; i<=n; i++){
				if(ch[i]==1) tmp+=(i+" ");
			}
			if(tmp.length()>0) System.out.println(tmp);
		}
		else{
            ch[L] = 1;   // 부분집합으로 사용한다.
            DFS(L+1); // 왼쪽으로 뻗을떄
            ch[L] = 0;   // 부분집합으로 사용하지 않는다.
            DFS(L+1) ; // 오른쪽으로 뻗을때
		}
	}

	public static void main(String[] args){
		Main T = new Main();
		n=3;
		ch=new int[n+1];
		T.DFS(1);
	}
}
```
D(n)은 부분집합에 해당원소 n을 넣는다 또는 뺀다를 의미한다고 하자.

<img src ="https://github.com/steadykyu/TIL/blob/master/Algorithm/%EC%9E%90%EB%B0%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%9D%B8%ED%94%84%EB%9F%B0/7.%20Recursive%2C%20Tree%2C%20Graph(DFS%2C%20BFS%20%EA%B8%B0%EC%B4%88)/img/7_6_1.png" width="50%" height="50%">

그럼 위와 같은 그림이 완성된다.

<img src ="https://github.com/steadykyu/TIL/blob/master/Algorithm/%EC%9E%90%EB%B0%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%9D%B8%ED%94%84%EB%9F%B0/7.%20Recursive%2C%20Tree%2C%20Graph(DFS%2C%20BFS%20%EA%B8%B0%EC%B4%88)/img/7_6_2.jpg" width="50%" height="50%">


1. 왼쪽 노드를 지날때마다 해당 배열 index에 1을 넣고 오른쪽 노드를 지날때는 index에 0을 넣는다.

+ ch배열의 index값 [1][2][3] 는 해당 숫자가 있는지 없는지를 의미한다. (보기 편하도록 0 index는 제외하도록 배열생성)

	- index값에 1이 들어가면 값이 있다는 의미(그림에서 O)
	- index값에 0이 들어가면 값이 없다는 의미이다.(그림에서 X)

2. L이 4가 될때, 해당 배열에서 존재하는 값만 출력해준다.
