# 설명


이전 8장의 DFS에서 비슷한 문제를 해결했었다. 그때는 동전의 종류 개수 N이 최대 12개였다. 그러나 현재 문제는 50개 까지 가능하므로, DFS나 BFS 전부 탐색하면 time limit이 발생한다.

이를 위해 냅색 알고리즘을 사용할 수 있다.

1. dy[]를 정의한다.
+ value에 매우 큰 값을 넣는다.

2. dy[i] : i 금액을 만드는데 드는 최소 동전의 개수
+ 예시 : dy[10] 10원을 만드는데 필요한 최소 동전의 개수

3. 각 동전의 종류별로 for문을 돌려주며, 아래 식으로 dy[] value를 넣어준다.

+ dy[j-coin[i]]+1
+ coin[i]가 2원이라고 해보자. 금액에서 2원을 빼줬으니, 2원동전 개수 1개를 더해주는 방식이다.

4. 


