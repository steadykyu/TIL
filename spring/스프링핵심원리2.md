## 글의 목적
+ 1편에 이어 자바를 통해 예제를 만들어보자. 
+ ppt 참조하면서 보자.
+ 우리는 비즈니스 요구사항을 이해하고 다형성을 통해 역할과 구현을 나눌 것이다.
+ 그리고 협력관계, 클래스 다이어그램, 객체 다이어그램을 이해하며, 회원과 주문 도메인을 개발해보고 테스트해보자.
## 목차
- [프로젝트 생성](#-------)
  
- [비즈니스 요구사항과 설계](#-------------)
- [회원 도메인 설계](#---------)
- [회원 도메인 개발](#---------)
- [회원 도메인 실행과 테스트](#--------------)
- [주문과 할인 도메인 설계](#-------------)
- [주문과 할인 도메인 개발](#-------------)
- [주문과 할인 도메인 실행과 테스트](#------------------)


## 프로젝트 생성
+ spring.io 에 들어가서 스프링 프로젝트를 만들고 다운받을수 있다.
+ group : 메타데이터
+ artifact : 프로젝트 빌드명
+ jar로 작업
+ 라이브러리를 아무것도 가져오지 않는다. -> 이러면 spring의 코어부트와 관련부트들만 가져와 준다.
### intellij 작업
+ file - setting -검색창에 gradle - Gradle을 intelliJ로 변경해주자. (그래야 더 빠른경향이 있음)
+ 참고 : build.gradle안 내용을 변경 하면 코끼리를 누르던가, reload해주어야함

## 비즈니스 요구사항과 설계
PPT 내용 읽기<br>
+ 회원 , 주문, 할인 정책이 존재하고 할인은 아직 미확정 상태이다. 또한 어떤 저장소를 쓸지도 미확정인 상태이다.
+ 우리는 정책이 결정될때까지 무기한으로 기다릴수 없다. 객체 지향설계 방법을 통해 인터페이스를 만들고 구현체를 갈아 끼울수 있도록 설계하면 된다.

## 회원 도메인 설계
요구사항에 알맞게 그림 3개를 살펴보자.
### 1. 회원 도메인 협력 관계
+ 기획자들에게 이해시킬 수 있는 그림이다.
+ 클라이언트 역할, 서비스 역할, 저장소의 역할을 가지게 된다.
+ 저장소는 DB나 외부 저장소로 언제든 교체할 수 있도록 생각해야한다.
+ 일단은 확정난게 없으니, 우리는 자바 메모리 회원 저장소로 만들기로 결정하자.

### 2. 회원 클래스 다이어그램(정적)
+ 구현한 클래스를 Implement이름을 따 Impl이라고 붙인다.
+ ***서버가 실행되지는 않은*** 상태로 보는 인터페이스와 클래스의 상태이다.
+ MemberRepository를 보면 어떤 DB가 될지, 외부DB가 어떻게 될 것인지 동적으로 결정이 된다.
+ 즉 서버가 뜰때, 객체를 만들고(new) 결정이 된다.
+ 그러므로 이 다이어그램으로는 어떻게 작업이 진행되는지는 전부 알 수없다.
+ 
### 3. 회원 객체 다이어그램(동적)
+ 실제 객체간의 참조관계에 대해 그려놓은 다이어그램
+ 우리는 임시로 메모리 회원 저장소로 만들기로 했으므로, 메모리 회원 저장소가 그려져 있다.

*주의*여기서 부터 저의 뇌피셜 정리입니다.<br>
이름이 길어서 약자로 작업합니다.
## 회원 도메인 개발
Grade : 회원등급을 enum으로 생성.(Grade안의 BASIC, VIP 외의 값은 쓰일수 없다.)
Member 클래스 : 회원 객체
MemberService : 회원가입을 하면 DB에 고객정보를 전달하고, 고객id를 통해 DB에 존재하는 고객객체를 꺼내주는 **역할**을 지닌 인터페이스 생성
MemberServiceImpl : MS를 구현한 객체
MemberRepository : 고객정보를 DB에 저장하고, 고객 id를 통해 DB에 존재하는 고객객체를 찾아주는 **역할**을 지닌 인터페이스 생성
MemoryMemberRepository: MR를 구현한 객체
참고사항
+ file -setting -keymap 에 단축키 동작을 검색하면, 단축키를 알려준다 ex) generate : alt insert
+ MMR 에서 Hashmap을 쓴 부분은 동시성 문제가 발생 할 수 있다. 그래서 실무에서는 ConcurrentHashmap을 사용한다.(추가공부)
+ 자동완성해주는 창에서 ctrl shift enter를 치면 추가 문법까지 자동완성해준다.(ex) new Me~()";" 까지 완성해줌)
+ MSl 의 join메서드에 호출하면, MR역할의 구현체인 MMR의 save가 오버라이드 되어 출력된다. 이런 부분을 다형성이라고 볼수 있다.

## 회원 도메인 실행과 테스트
+ 위의 회원 객체 다이어그램과 같이 인스턴스 참고그림이 잘 만들어졌는지 런타임을 통해 테스트해보자.
+ 우리는 테스트를 main에서 출력해서 할수도 있고, JUnit test프레임워크를 이용할 수 있다.
### 1. main함수에서 하기.
+ Memberapp 클래스를 만들고 main 함수안에서 pt와 같이 실행하자.
+ Member객체를 만들어주는 방식은 클라이언트가 와서 회원가입한 상황을 대변해준다.
+ 우리가 입력해준(만든 객체) member와 DB에서 가져온 member의 이름이 같은것을 확인 할수 있었다.
+ 그러나 이런 방식은 좋은방법이 아니다. JUnit 테스트를 사용하자.

### 2. JUnit test프레임워크
+ @Test 가 import 되어야한다.
+ test할 메서드에 given when then으로 나누면 훨씬 좋다!
+ 회원 도메인 설계의 문제점
  1.이 코드의 설계상 문제점은 무엇일까요?
  2.다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까요?
  3.DIP를 잘 지키고 있을까요?
이거 답변다하면 아래 안봐도 된다. 근데 1번을 모르겠다. 나중에 돌아와보자(추가공부)<br>
+ 참고
+ id 값 1L은 Long 타입이기때문에 써준 것이다. 
+ Long타입 데이터 설정은 DB에 null도 들어갈 수 있으므로 wrapper형 변수를 사용하였다.
+ soutv 단축키를 활용하면 ("변수k" = 변수k 인스턴스값) 의 껍데기를 만들어 준다.
+ org.assertj.core.api.Assertions; 의 여러메서드를 통해 값비교가 가능하다, 테스트할때 꼭써주자.
+ MSI를 보면 MR인터페이스에 의존한다. 그런데, 구현체(MMR)까지 의존하고있다.(일단 알고있으면 의존한다고 봄)
+ 즉 추상화에도 의존하고 구체화에도 의존하고 있다.(DIP를 위반)

## 주문과 할인 도메인 설계
주문, 할인정책 요구사항(pt 확인)
+ 회원은 상품을 주문할수 있다. 원래라면 상품객체를 만들어 DB 넣어주고 해야하지만, 우리는 예제를 쉽게만들기위해 
상품이름과 가격을 직접 입력하고 주문결과만 반환할 것이다..
+ 할인정책은 변경가능성이 높다.

### 1.1주문 도메인 협력, 역할, 책임
+ 역할들이 보이는 그림
+ 이제는 클라이언트가 주문이다.(뇌피셜)

### 1.2주문 도메인 전체
역할과 구현을 분리해서 담은 그림

### 2.주문 도메인 클래스 다이어그램
+ 회원서비스도 그랬고, 주문서비스도 그렇지만
+ 이렇게 역할과 구현체가 하나만 있는경우에 Impl를 붙여주는 관습이있다.

### 3.주문 도메인 객체 다이어그램1,2
+ 실제 객체들(인스턴스를) 생성해서 맺어지는 상태의 그림
+ 그림과 설명을 읽어보면 주문서비스를 변경하지 않고도 ***역할들이 협력 관계를 그대로 재사용 하는 모습***을 볼 수 있다.

## 주문과 할인 도메인 개발
Order : 주문객체
+ main 함수에서 확인하기위해 toString() 추가
DiscountPolicy : 멤버의 등급에 따라 할인액을 부여하는 역할
FixDiscountPolicy : DiscountPolicy역할의 구현체들 중 정액할인구현체
OrderService 
+ DB에 있는 member객체를 가져오고 
+ 할인액이 얼마인지 구하고, 그 데이터들로 주문을 생성하는 역할
OrderServiceImpl : 구현체
+ 주문 생성 요청이 오면, 회원 정보를 조회하고, 할인 정책을 적용한 다음 주문 객체를 생성해서 반환한다.
+ 일단은 메모리 회원 리포지토리와, 고정 금액 할인 정책을 구현체로 생성했다.
+ 참고사항
+ \/** enter 로 주석기능이 가능하다.
+ Enum 타입은 "==" 으로 비교해야한다.
+ Orderservice는 설계상으로 보면 두개의 역할이 필요하므로,  MR, DP를 가져와준다.
+ OrderService입장에서는 할인정책에 대해 모른다. 그저 member와 itemPrice에 알맞은 할인정책 가져오라고 하고 주문을 만들뿐이다.
+ 만약 할인 정책이 바뀐다면 ,우린 할인정책의 구현체만 바꿔주면 된다. 
+ 즉 단일체계원칙(SRP)을 잘 지킨 설계 부분이다.

## 주문과 할인 도메인 실행과 테스트
회원이 생기고, 회원이 주문생성을 하면 알맞은 할인 금액이 출력되는지 테스트 해보자.
### 1. OrderApp의 main 메서드에서 작업.
+ System에 toString()을 해주면 원래라면 클래스명과 주소값이 나오지만, 우리가 오버라이드 했기 때문에 설정한 결과가나온다.
+ 할인 금액이 잘 출력된 것을 볼수 있다.(1000원)

### 2. 주문과 할인 정책 테스트
+ VIP 멤버가 주문을 생성했을때, 할인금액이 1000원 잘 들어갔나 확인이 가능하다.(테스트에 에러가 안뜸).
+ 참고사항
+ 이런 단위테스트를 잘 만들어야한다.
+ 스프링 부트가 섞인, 여러라이브러리가 섞인 Core에 테스트하면 테스트시간이 너무길어지고, 알기도 힘들다.
+ 그러므로 자주 단위테스트를 하고 기록해두어야한다.

우리는 다형성을 통해 역할과 구현을 나누고 회원과 주문 도메인을 개발했다. <br>
과연 정률할인 정책으로 바꾸었을때 좋은 객체지향설계(SOLID)으로 만들어지는가 확인해보면서<br>
스프링핵심원리3.md를 보자.<추가공부 여기하이퍼링크 다는법 나중에해두기>

