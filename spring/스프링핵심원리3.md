## 글의목적 
이전에 우리는 다형성을 이용하여 각각의 역할과 구현체를 만들었다.
앞으로는 다형성으로 작성한 코드에 발생하는 Ocp, DIP 위반과 이를 해결하기 위한 노력들(IOC, DI 컨테이너)를 공부해보자.
그리고 이런 원리를 통해 만들어진 스프링을 사용해보자.
## 목차

## 새로운 할인정책 개발
+ RateDistcountPolicy 구현 : 멤버와 물건 가격에 대하여 멤버가 VIP라면 10프로 할인해주는 구현체를 만들자. 
+ 테스트를 작성하여, 가격값을 넣었을때 할인액이 가격의 10% 인지를 확인하자.
+ 참고사항
+ 애자일 소프트웨어 선언 [https://agilemanifesto.org/iso/ko/manifesto.html]
+ 테스트 껍데기 단축키 : ctrl shift T
+ 일부로 틀려보자. 콘솔창에 기대값과 실제값이 나온다.
+ Assertions에서 alt enter를 하여 on demand *static import*를 해주는 것이 더 좋다.

## 새로운 할인 정책 적용과 문제점
```java
public class OrderServiceImpl implements OrderService {
// private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
 private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
}
```
+ 할인 정책을 RDP로 바꿔주었다. 그런데 여기서 문제가 발생한다.
+ 문제점 발견
+ pt 그림 참고
+ 실제 의존관계 : OSI가 FDP 와 RDP 둘다 의존하고 있다.(객체 생성이 OSI에서 이루어 지고있으므로) -DIP위반
+ 정책 변경 : FDP에서 RDP로 바꾸려면 OSI코드를 수정해야한다. - OCP 위반
****
+ 어떻게 문제를 해결해야 할까?
+ 먼저 DIP 위반을 막기위해 RD 인터페이스에만 의존하도록 인터페이스를 수정하자.
```java
public class OrderServiceImpl implements OrderService {
 //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
 private DiscountPolicy discountPolicy;
}
```
+ final은 값을 할당해야하기때문에, 인터페이스만 의존시킬때는 빼준다.
+ 이제 인터페이스에만 의존하도록 해주었다.
+ 실행하면 인스턴스가 없으므로 당연히 NPE(null pointer exception)가 발생한다.
+ 결국 현재 클라이언트인 OSI에 DP구현객체를 주입해줄 누군가가 있어야한다.
+ 다시 FDP가 작용되고 있다고 생각하고 아래의 방법으로 RDP로 변경해보자.

## 관심사의 분리-매우중요
+ 공연(APP)을 구성하고, 담당배우를 섭외하고(객체생성), 역할에 맞는 배우(인터페이스와 구현체연결)를 
+ 지정하는 책임을 담당하는 별도의 ***공연 기획자*** 가 필요하다.

### AppConfig 등장
+ 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는
별도의 설정 클래스를 만들자.
```java
Appconfig 내부
public MemberService memberService() {
  return new MemberServiceImpl(new MemoryMemberRepository());
 }
 public OrderService orderService() {
   return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
 }
 ```
+ 이전에는 우리가 MSI(구현체)에서 MMR객체를 만들었었다. 
+ 이제는  Appconfig에서 구현 객체를 생성하는 부분들을 만든다.

### MSI, OSI 생성자 주입
+ MSI는 중복이라 생략함.(PT참조)
+ AppConfig는 객체 인스턴스의 참조를 생성자를 통해 주입(연결해준다)
```java
public class OrderServiceImpl implements OrderService {
   private final MemberRepository memberRepository;
   private final DiscountPolicy discountPolicy;
   public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
     this.memberRepository = memberRepository;
     this.discountPolicy = discountPolicy;
 }
 ```
 + OSI에는 이제 FDP나 RDP를 의존하지 않게된다.(보이지 않음) 
 + 단지 DP만 의존하고 있다. - DIP문제 해결
 + OSI 입장에서는 생성자를 통해 어떤 구현 객체가 들어올지 알수 없다.
 + 어떤객체를 주입할 지는 오직 외부(AppConfig)에서만 결정한다.
 + OSI는 이제 실행에만 집중하면 된다.
 + OSI 입장에서는 MMR과 FDP객체의 의존관계가 주입된다. 이러한 주입되는 관계를 DI 의존관계주입이라고 한다.

### AppConfig 실행
#### MemberApp 코드수정
```java

public static void main(String[] args) {
   AppConfig appConfig = new AppConfig();
   MemberService memberService = appConfig.memberService();
 ```
+ 이제 테스트에서 AppConfig 객체를 부르고, appConfing 참조변수를 통해 메서드를 호출한다. 
+ 메서드에서는 알맞은 객체를 생성(new MCI)하고 (MMR객체를)주입한다.
#### OrderApp 코드수정
```java

 public static void main(String[] args) {
   AppConfig appConfig = new AppConfig();
   MemberService memberService = appConfig.memberService();
   OrderService orderService = appConfig.orderService();
 ```
+ 메서드는 알맞은 객체를 생성(new OSI)하고 OSI에 생성자로 (MMR객체, FDP객체)주입를한다.
+ MS, OS 인터페이스는 만들어진 MSI, OSI객체로 결국 구현이 된다.
#### 테스트 코드 오류 수정
```java
class MemberServiceTest {
   MemberService memberService;
   @BeforeEach
   public void beforeEach() {
   AppConfig appConfig = new AppConfig();
   memberService = appConfig.memberService();
   }
}
```
테스트 코드에서 @BeforEach는 각 테스트를 실행 하기전에 호출되는 에노테이션이다.(각 테스트 -> 그때그때 객체생성)
#### 정리
pt 읽기
이제 OSI는 인터페이스에만 의존하고 있다.(DIP) 그러므로 구현클래스가 어떻게 되던간에 신경쓸 필요가없다.
동시에 단일책임원칙이 지켜지기도 했다.

### AppConfig 리팩터링
PT참고 : 변경 전과 변경후의 코드를 보자.
+ 코드중복일 줄일뿐만아니라, code만 봐도 각각의 역할과 구현모습이 그려진다.
+ 아래 나오는 다이어그램 그림과 같은(역할, 구현클래스 다이어그램) 모양과 코드가 일치하고 있다.
+ 참고사항
+ ctrl alt m : 중복대상에 사용하면 , 리팩토링이 가능함. 
+ 한번더 누르면 타입과 이름 수정가능

## 새로운 구조와 할인 정책 적용
+ FDP -> RDP로 정책을 변경해 보자.
+ 그저 구성영역의 코드만 수정하면 된다.
+ 기능을 RatePoilcy로 바꿨지만(기능확장), 클라이언트 코드를 변경시키지 않았다.
+ OCP가 지켜지고 있는것이다.

## 전체흐름정리
+ PT읽기

## 좋은 객체 지향 설계의 5가지 원칙
+ 우리의 코드에서는 SRP, DIP, OCP 적용되고 있다.
+ PT읽기
### SRP
이전의 (클라이언트)OSL, MSL은 너무 다양한 책임을 가졌음.
SRP 단일 책임 원칙을 따르면서 관심사를 분리함

### DIP
+ 이전의 OSL , MSL 은 추상화가 구체화에 둘다 의존하고 있었다.
+ Appconfig와 생성자주입으로 둘다 인터페이스만 의존하게 됨.

### OCP
+ PT
### IOC, DI 그리고 컨테이너
+ PT
### 프레임워크 VS 라이브러리
+ Jnit 프레임워크 : 나는 로직만 만들었는데 beforeEach를 먼저 실행하고 @test를 실행함.<br>
제어권을 JUit framework가 가지고 있기 때문이다.<br>
+ Json으로 바꾸는 라이브러리 : 만약 자바객체를 라이브러리를 가져와서 json으로 바꿧다고하자.<br>
바꾼 결과값은 결국 내가 제어함.

### 의존관계 주입(DI)
+ 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.

#### 정적인 클래스 의존관계
+ pt
+ 그림의 화살표 방향이 의존하고 있다는 의미이다.
+ OSL 코드를 보고 클래스 다이어그램의 설계가 생각나야한다.
+ 화살표 방향이 의존하고있다는 의미이다.
#### 동적인 클래스 의존관계
+ pt
+ ex ) OSL 코드만 보고서는 어떤 할인이 올지 어떤 DB가 올지 알수가 없다. 이런건 실행해야만 알수가 있다.
+  클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다. = (정액정책 -> 정률정책)
+  정적 의존관계변경x  = 클래스 다이어그램이 전혀 바뀌지않았다.(코드를 건들지 않음)
+  동적인 객체 인스턴스 의존관계를 쉽게 변경 = 객체 다이어그램은 쉽게 변경가능

### IOC컨테이너, DI 컨테이너
+ pt

## 스프링으로 전환하기
### AppConfig 스프링으로 전환하기.
```java
@Configuration
public class AppConfig {
   @Bean
   public MemberService memberService() {
   return new MemberServiceImpl(memberRepository());
   }
   .........
```
+ 설정정보인 @Configuration과 @Bean을 입력하면 이름은 메서드이름으로
+ value는 만들어지는 객체를 스프링 Bean에 등록한다.
+Bean에 저장되는 이름을 바꿀 수도 있다. @Bean(name= "") 근데 default를 따르는게 좋다
### MemberApp에 스프링 컨테이너 적용   
```java
   public class MemberApp {
 public static void main(String[] args) {
 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
 MemberService memberService =applicationContext.getBean("memberService", MemberService.class);
```
+ 이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만
+ 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 
+ 스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾을 수 있다.
+ 코드가 약간 더 복잡해진 것 같은데, 스프링 컨테이너를 사용하면 어떤 장점이 있을지 알아보자.
