## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

핵심주제 : 스프링 컨테이너를 왜사용하는걸까?
+ 현재까지의 나의 생각
+ BeanFactory 에 있는 빈 조회기능들, 특히 ApplicationContext interface에 있는 부가기능들로 Java App을 제작하는데 도움을 줄 수 있다.
+ 다양한 설정 형식을 지원한다.(java 코드로 된 애노테이션 설정 기법에서 , xml을 파일을 통한 설정정보로 교체할 수있다.(굳이 따지자면 다형성)
+ 

## 목차

## 웹 애플리케이션과 싱글톤
+ 웹 애플리케이션은 보통 여러고객이 동시에 요청한다.
### 스프링이 없는 순수한 DI 컨테이너 테스트
```java
    @Test
    @DisplayName("스프링 없는 순수한 DI 컨테이너")
    void pureContainer(){
        AppConfig appConfig = new AppConfig();
        //1. 조회 : 호출 할 때 마다 객체를 생성
        MemberService memberService1 = appConfig.memberService();

        //2. 조회 : 호출 할 때 마다 객체를 생성
        MemberService memberService2 = appConfig.memberService();

        //참조값이 다른 것을 확인해보자
        System.out.println("memberService1 = " + memberService1);
        System.out.println("memberService2 = " + memberService2);
        // memberService1 != memberService1
        assertThat(memberService1).isNotSameAs(memberService2);
    }
 }
 ```
<img src ="https://github.com/steadykyu/TIL/blob/master/spring/captureimg/result1.png" width="50%" height="50%">
+ 우리가 만들었던 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성한다.
+ 고객 트래픽이 초당 100이 나오면 초당 100개 객체가 생성되고 소멸된다! 메모리 낭비가 심하다.
+ 해결방안은 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 된다. - 싱글톤 패턴

## 싱글톤 패턴
+ 클래스의 객체인스턴스가 현재 jvm내에 하나만 생성되는것을 보장하는 디자인 패턴
+ 여러 방법이 있지만, private 생성자를 이용해서 new 키워드를 못하게 해보자.
```java
public class SingletonService {

    private static final SingletonService instance = new SingletonService();

    public static SingletonService getInstance(){
        return instance;
    }
    // 외부클래스 에서 값 수정을 막아준다.
    private SingletonService(){
    }
```
1. static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.
2. 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를호출하면 항상 같은 인스턴스를 반환한다.
3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.
<img src ="https://github.com/steadykyu/TIL/blob/master/spring/captureimg/result2.png" width="50%" height="50%">
+ 인스턴스 객체가 일치하는 모습을 볼 수 있다.
+ isSameAs 는 인스턴스 객체 비교(==), isEqualAs 는 값 비교이다.
### 싱글톤 패턴의 문제점
1. 코드 자체가 너무 많아진다.
2. 의존관계상 클라이언트가 구체 클래스에 의존한다.(DIP 위반)
```java
public MemberService memberService(){
return new MemberServiceImpl.getInstance(memberRepository());
}
```
3. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다
4. 테스트하기 어렵다.(이미 인스턴스가 생성되어있음)
5. 결론적으로 유연성이 떨어진다 (코드 전부에 getInstance를 하거나, 필요한 메서드를 또 만들고 다 추가해주어야함)
## 싱글톤 컨테이너
+ 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 지금까지 우리가 학습한 스프링 빈이 바로 ***싱글톤으로 관리되는 빈***이다.
+ 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
+ 결국 DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.
```java
        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        //1. 조회 : 호출 할 때 마다 객체를 생성
        MemberService memberService1 = ac.getBean("memberService", MemberService.class);

        //2. 조회 : 호출 할 때 마다 객체를 생성
        MemberService memberService2 = ac.getBean("memberService", MemberService.class);
        System.out.println("memberService1 = " + memberService1);
        System.out.println("memberService2 = " + memberService2);
        assertThat(memberService1).isSameAs(memberService2);
```
<img src ="https://github.com/steadykyu/TIL/blob/master/spring/captureimg/result3.png" width="50%" height="50%">
+ 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.
+ 싱글톤 방식이 아닌 요청할때마다 새로운 객체를 생성하는 기능도 있다.(추후배움)

## 싱글톤 방식의 주의점
+ 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
+ 그러므로 무상태 설계를 해야한다.
> 특정 클라이언트에 의존적인 필드가 있으면 안된다.
> 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
> 가급적 읽기만 가능해야 한다.
> 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
```java
public class StatefulService {

    private int price;
//  싱글톤 패턴에서 필드가 공유되버리는 경우
    public void order(String name, int price){
        System.out.println("name = " + name + " price = " + price);
        this.price = price; //여기가 문제!
    }
        public int getPrice(){
        return price;
    }
```
테스트 코드 일부
```java
    statefulService1.order("usrA",10000);
    statefulService2.order("usrB",20000);
    int price = statefulService1.getPrice();
    System.out.println("price = " + price);
```
+ usrA는 10000이 들어가야하는데, 20000으로 들어간다.
+ StatefulService 의 price 필드는 공유되는 필드이기때문에, userA의 필드값을 usrB가 변경한다.
+ 진짜 공유필드는 조심해야 한다! 스프링 빈은 항상 무상태(stateless)로 설계하자

## @Configuration과 싱글톤
@Configuration을 이해하기위해, Appconfig.class를 보자.
```java
@Configuration
public class AppConfig { 
    @Bean
    public MemberService memberService(){
        System.out.println("Call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository() {
        System.out.println("Call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }
    @Bean
    public OrderService orderService(){
        System.out.println("Call AppConfig.orderService");
        return new OrderServiceImpl(
                memberRepository(), discountPolicy());
    }
    //@Bean memberService() -> new MemberServiceImpl -> memberRepository -> new MemoryMemberRepository()
    //@Bean orderService -> new OrderServiceImpl -> memberRepository -> new MemoryMemberRepository()
    
    //자바 코드 해석시 예상결과
    //Call AppConfig.memberService
    //"Call AppConfig.memberRepository");
    //Call AppConfig.memberRepository
    //"Call AppConfig.orderService"
    //Call AppConfig.memberRepository ...

    //실제 결과
    //Call AppConfig.memberService
    //Call AppConfig.memberRepository ...
    //"Call AppConfig.orderService"
```
+ 원래 우리의 자바 코드해석식으로 보면 예상결과가 나와 싱글톤이 깨져야한다.
+ getMemberRepository()를 이용하여 실제결과를 봐보자.
+ 예상과 다르게 memberRepository가 중복출력되지 않았다. 왜그럴까?


## @Configuration과 바이트코드 조작의 마법
+ 스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야한다. 
+ 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
```java
@Test
    void configurationTestDeep(){
        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        //AppConfig도 스프링 빈으로 등록된다. 그러므로 타입으로 찾을 수 있다.
        AppConfig bean = ac.getBean(AppConfig.class);
        //출력: bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70
        System.out.println("bean = " + bean.getClass());
```
+ 사실 AnnotationConfigApplicationContext에 파라미터로 넘긴 값은 스프링 빈으로 등록된다. 그래서 AppConfig 도 스프링 빈이 된다.
+ AppConfig 설정정보를 가지고 있는 Bean의 클래스를 보면 기본 클래스 경로(class hello.core.AppConfig) 뒤에 ...CGLIB 의 모습이 보인다.
+ 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스(예명으로 CGlib라고하자)를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다!
+ 이 CGlib는 컨테이너속에서 이름은 appConfig이지만, 인스턴스 객체는 이 CGlib 를 통해 생성된 것을 쓰고 있는 것이다.
+ CGlib클래스가 어떻게 객체들을 생성하는지는 복잡하다.아마 논리적으로 대략적으로는 다음과 같을 것이다.
```java
public class CGLIB{
    @Bean
    public MemberRepository memberRepository() {

     if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면?) {
     return 스프링 컨테이너에서 찾아서 반환;
     } else { //스프링 컨테이너에 없으면
     기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록
     return 반환
     }
}
```
+ @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 
+ 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. 덕분에 싱글톤이 보장되는 것이다
+ 참고: AppConfig@CGLIB는 AppConfig의 자식 타입이므로, getbean()에서 AppConfig 타입으로 조회 할 수 있다.
+ @Configuration이 없으면, 설정정보에 있는 MS, MR, OS 전부다 다른 Repository를 사용할 것이다.(확인은 pt보기)
## 정리
+ @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
+ memberRepository() 처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 때 싱글톤을 보장하지 않는다.(DI는 일어나지만 싱글톤 보장은 일어나지 않음)
+ 크게 고민할 것이 없다. 스프링 설정 정보는 항상 @Configuration 을 사용하자
