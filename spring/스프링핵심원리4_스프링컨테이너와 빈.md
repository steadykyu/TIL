## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

핵심주제 : 스프링 컨테이너를 왜사용하는걸까?

## 목차

## 스프링 컨테이너 생성
```java
ApplicationContext applicationContext =new AnnotationConfigApplicationContext(AppConfig.class)
```
+ ApplicationContext은 스프링 컨테이너이면서 인터페이스이다.
+ AnnotationConfigApplicationContext는 인터페이스의 구현체이다.
+ AppConfig.class 는 우리가 설정해준 설정정보클래스이다.
+ 스프링 컨테이너는 XML기반으로도 되지만, 주로 애노테이션 기반의 자바 설정클래스로 만든다.

1. 스프링 컨테이너 생성
2. 스프링 빈 등록
3. 스프링 빈 의존관계 설정-준비
4. 스프링 빈 의존관계 설정-완료
  + 스프링 컨테이너는 설정정보(AppConfig)를 참고해서 의존관계를 주입(DI)한다.동적 인스턴스값들끼리 참조가 일어남)

## 컨테이너에 등록된 모든 빈 조회
+ 모든 빈을 출력해보자.
+ 애플리케이션 빈을 출력해보자.(내가 등록한 빈만 출력하기)
+ cf) 애플리케이션이란? 사용자 또는 어떤 경우에는 다른 응용프로그램에게, 특정한 기능을 직접 수행하도록 설계된 프로그램이다.
+ ROLE_APPLICATION , ROLE_INFRASTRUCTURE

## 스프링 빈 조회-기본
+ ac.getBean(빈이름, 타입)
+ ac.getBean(타입) -> 빈속의 value(구현체)를 리턴해준다.
+ 빈이름과 타입으로, 이름없이 타입으로만, 구현체타입으로 조회해보자.
+ 타입으로만 했을때는 이름 중복위험이 있다.
+ 구현체 타입은 역할과 구현을 분리한 객체지향설계에 좋은 코드는 아니다.
+ 새로운 테스트 프레임워크의 방법 **assertThrows**
```java
    @Test
    @DisplayName("없는 빈 이름으로 조회")
    void findBeamByNameX(){
//        ac.getBean("xxxxx",MemberService.class);
//        MemberService xxxxx = ac.getBean("xxxxx", MemberService.class);
        assertThrows(NoSuchBeanDefinitionException.class,
                () -> ac.getBean("xxxxx", MemberService.class));
    }
```
+ assertThrows 는 junit 쪽으로 import해야 쓸수 있는 메서드이다.
+ 매개변수에 예외와 예외상황을 매개변수로하고, 예외가 터지면 테스트 성공, 안터지면 실패이다.

## 스프링 빈 조회-동일한 타입이 둘 이상
ac.getBeansOfType() -> 리턴자료형 Map<String, <>>로 Map형태로 리턴한다.
해당 타입의 모든 빈 조회가 가능하다.
```java
@Test
 @DisplayName("특정 타입을 모두 조회하기")
 void findAllBeanByType() {
 Map<String, MemberRepository> beansOfType =ac.getBeansOfType(MemberRepository.class);
   for (String key : beansOfType.keySet()) {
    System.out.println("key = " + key + " value = " +
    beansOfType.get(key));
    }
 System.out.println("beansOfType = " + beansOfType);
 assertThat(beansOfType.size()).isEqualTo(2);
 }
```
1. 타입으로 조회시 같은 타입이 둘 이상 있으면, **중복 오류**가 발생한다.
2. 그러므로 타입으로 조회시 같은 타입이 둘 이상 있으면, **빈 이름을 지정**하면 된다
3. 특정 타입을 모두 조회하기
+ 이 원리를 알아야 나중에 @Autowhile을 이해하는데 도움이 된다.
+ 참고: 클래스 안에 정적클래스를 만드는 것은 정적클래스를 이 외부클래스에서만 쓰겠다고 하는 것과 같은 의미이다.

## 스프링 빈 조회-상속 관계
+ 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
+ 그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회한다.
```java
@Test
 @DisplayName("부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다")
 void findBeanByParentTypeDuplicate() {
   //DiscountPolicy bean = ac.getBean(DiscountPolicy.class);
    assertThrows(NoUniqueBeanDefinitionException.class, 
    () -> ac.getBean(DiscountPolicy.class));
  }                        
```
1. 부모 타입으로 조회시, 자식이 둘 이상 있으면, **중복 오류**가 발생한다 (ex) DP 는 FDP, RDP가 있다. getBean(DP) 시 오류가 발생한다.
2. 부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정하면 된다(getbean 매개변수에 입력)
3. 특정하게 하위 타입으로 조회(문제는 없다. 그러나 역할과 구현분리를 위해 사용하지 않는 편이좋다.)
4. 부모 타입으로 모두 조회하기
 + 위의 조회할때 사용한 ac.getBeansOfType(DiscountPolicy.class);로 조회 가능하다.<br>
5.부모 타입으로 모두 조회하기 - Object 
 + getBeansOfType에 Object넣을시 스프링이 쓰는 내부 빈에서 내가 만들어준 빈까지 모두다 달려서 나온다.<br>

## BeanFactory와 ApplicationContext
### BeanFactory
+ 스프링 컨테이너의 최상위 인터페이스이다.
+ 우리가 지금까지 사용한 스프링 빈을 관리하고 조회하는 역할을 담당한다.

### ApplicationContext
+ BeanFactory 기능을 모두 상속받아서 제공
+ 애플리케이션을 개발할 때, BeanFactory 기능을 넘어 부가기능을 제공한다.
1. 메시지소스를 활용한 국제화 기능
2. 환경변수(로컬, 개발, 운영으로 구분하여 처리)
3. 애플리케이션 이벤트
4. 편리한 리소스 조회
+ BeanFactory나 ApplicationContext를 스프링 컨테이너라고 부르며, 주로 ApplicationContext를 사용한다.

## 다양한 설정 형식 지원 - 자바 코드, XML
스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.
### 애노테이션 기반 자바 코드 설정
+ new AnnotationConfigApplicationContext(AppConfig.class)로 지금까지 우리가 해온 방식이다.

### XML 설정 사용
+ xml 파일을 설정자로 입력받는다.
+ ref에 class객체가 생성자주입과함께 들어간다.
+ xml 기반의 appConfig.xml 스프링 설정 정보와 자바 코드로 된 AppConfig.java 설정 정보를 비교해보면 거의 비슷하다는 것을 알 수 있다.
+ 최근에는 쓰지않는다. 레거시 프로젝트들이나, 컴파일 없이 빈설정정보를 확인 할수 있는정도만 알고있으면 될듯하다.

### 스프링 빈 메타정보 -BeanDefinition
+ 이전에 우리가 역할과 구현(여러구현체들)로 분리한 관계가 BeanDefinition과 설정정보들의 관계와 일치한다.
+ 스프링 컨테이너는 오직 BeanDefinition에 의존관계이다.
+ (뇌피셜: 런타임시, 스프링컨테이너의 구현체와 BeanDefinition이 연결될때 의존관계주입이 일어난다.)
+ XML설정정보로 구현하면 XML설정방식으로 구현, JAVA설정정보로 구현하면 애노테이션구현체 처럼 스프링 컨테이너는 오직 BeanDefinition만 알면 된다.
+ @Bean,<bean>당 각각 하나씩 메타정보를 생성한다.
+ BeanDefinition을 빈 설정 메타정보라고 부른다.
```java
 @Test
 @DisplayName("빈 설정 메타정보 확인")
 void findApplicationBean() {
   String[] beanDefinitionNames = ac.getBeanDefinitionNames();
     for (String beanDefinitionName : beanDefinitionNames) {
        BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);
       if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {
       System.out.println("beanDefinitionName" + beanDefinitionName +" beanDefinition = " + beanDefinition);
        }
     }
}
```
+ getBeanDefinitionNames()로 확인해볼 수있다.
+ 일반적인 BeanDefinition의 이름은 Bean에 디폴트로 넣어진 이름들에 Definition이 붙는다.(ex)memberServicebeanDefinition)
+ BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다. 하지만 실무에서 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다.(리스크)
+ BeanDefinition에 대해서는 너무 깊이있게 이해하기 보다는, 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다. 
+ (BeanDefintion에 설정정보(Appconfig.java, appConfig.xml등)를 구현체로 넣어 사용하기때문에 추상화해서 사용한다고 말한다.)
