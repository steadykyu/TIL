## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

핵심주제 : 스프링 컨테이너를 왜사용하는걸까?
+ 현재까지의 나의 생각
****
+ App을 만드는데, 좋은객체지향설계로 만들 수 있다.(다형성,OCP, DIP만족시키고, DI를 좀더 편하게 제공)
****
+ BeanFactory 에 있는 빈 조회기능들, 특히 ApplicationContext interface에 있는 부가기능들로 Java App을 제작하는데 도움을 줄 수 있다.
****
+ 다양한 설정 형식을 지원한다.(java 코드로 된 애노테이션 설정 기법에서 , xml을 파일을 통한 설정정보로 교체할 수있다.(굳이 따지자면 다형성)
****
+ 웹사이트는 동시에 오는 요청이 많다. 이에 대해 Bean 컨테이너를 싱글톤패턴으로 만들어 주는 @Configuration을 사용하면 공유하는 객체를 이용하여 메모리 낭비를 줄일 수 있다.
+ @Configuration을 설정정보 클래스(AppConfig.class)에 입력해주면, Bean 컨테이너는 싱글톤 컨테이너로 만들어진다. 
****
+ 스프링빈을 몇천개 만들어야 하는 상황이라면, @Bean을 몇천번 입력해야할 뿐더러 실수가 나올 확률이 클 것이다.
+ 이럴때는 구현체에 @ComponentScan과 @Component, 구현체의 생성자에 @Autowired를 사용하면 스프링이 컨테이너 안에 빈이름과 빈객체을 만들어주고, Autowired룰 방식에 따라 자동으로 DI를 해준다.
+ 그러므로 AppConfig(설정정보)에 작성해야했던 소스코드를 저 두종류의 애노테이션으로 만들 수 있게 된 것이다.
****
+ 위에서 배운 Autowired는 자동으로 DI 작업해주기 때문에 편리함을 주지만, 그렇기 때문에 어떻게 돌아가는지 알고 있어야한다. 
+ 또한 스프링에서 제공하는 기능은 자동으로 돌아가도록, default설정을 유지하여 명확성를 올리자.(스프링 로직 아는 개발자가 보면 코드를 보자 마자 알수 있도록)
+ 기술지원 빈이 필요하거나 다양한 비즈니스로직을 위해 다형성을 사용해야하는 상황이 있다면 Config클래스에 수동적으로 @Bean을 만들어 다른 개발자들이 작업하기 편하도록 할 수 있다.
****
8.
+ App들은 대부분 RDMS 쓰는데 App서버가 올라올 때 미리 DB랑 연결을 맺거나 소켓설정을 할수 있다. 이를 통해 고객요청이 왔을때 미리 DB를 연결로 값을 넣고, 소켓을 열어줄수 있다. 이런 기능이 작동하기 위해서 우리는 객체에 외부 값들에 대한 초기화를 해야한다. 이런 과정에서 빈의 생성 직후 바로 초기화를 하고, 빈이 죽기직전에는 호출을 해줄 수 있는 생성주기 콜백이 필요하다.
+ 객체의 초기화와 종료를 위해서 주로 @PostConstruct, @PreDestroy애노테이션을 사용한다. 하지만 이 둘은 외부 라이브러리를 초기화 해주지 못한다.
+ 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를 사용하자.
****
> 9
+ 이전의 빈의 생성과 죽는 다는 것을 알았다. 이런 빈은 시작 부터 언제 죽는지 까지를 범위한 빈 스코프란 이름이 있으며, 여러 종류의 빈 스코프가 존재한다.
+ 스프링 컨테이너의 요청에 생성하지만 초기화까지만 하고 스프링컨테이너에 관리 받지 않는 프로토타입빈
+ 여러 웹에서의 작동과 관련된 스코프들
+ 스코프들이 적절하게 움직이도록 도와 주는 Provider(DL이용) 와 프록시
+ 대부분 싱글톤 빈 스코프로 작업할수 있으나, 특별한 경우에는 다른 스코프를 이용하여 문제해결을 할 수 있다.
## 목차

## 빈 스코프란
+ 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.(지금까지 우리가 써온 스코프)
+ 프로토타입: 스프링 컨테이너가 프로토타입 빈의 생성과 의존관계 주입까지만 관여한다. 이후 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
> 웹 관련 스코프
+ request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
+ session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
+ application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.
### 스코프 사용법
```
@Scope("prototype")
@Component
public class HelloBean {}
```
+ 자동등록
```
Scope("prototype")
@Bean
PrototypeBean HelloBean() {
 return new HelloBean();
}
```
+ 수동 등록
## 프로토타입 스코프
+ 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 ***새로운 인스턴스***를 생성해서 반환한다.
+ 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다.
+ 그러므로 종료메서드가 호출되지 않는다. 굳이 조회하려면 클라이언트가 직접 해주어야한다.
+ 만약 프로토타입 빈을 2번 조회한다면, 완전히 다른 두개의 스프링 빈이 생성되고, 초기화도 2번 실행될 것이다.
## 프로토타입 스코프-싱글톤빈과 함께 사용시 문제점
### 프로토타입 빈 직접요청을 여러번 한다면
```java
@Scope("prototype")
    static class PrototypeBean{
        private int count = 0;
        public void addcount(){
            count++;
        }
        public int getCount(){
            return count;
        }
        @PostConstruct
        public void init(){
            // this 하면 나를 찍으므로, 나의 참조값(주소값)을 볼수 있다.
            System.out.println("PrototypeBean.init" + this);
        }
        @PreDestroy
        public void destroy(){
            System.out.println("PrototypeBean.destroy");
        }
    }
```
```java
@Test
    void prototypeFind(){
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        //클라1의 요청
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        prototypeBean1.addcount();
        assertThat(prototypeBean1.getCount()).isEqualTo(1);
        //클라2의 요청
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        prototypeBean2.addcount();
        assertThat(prototypeBean2.getCount()).isEqualTo(1);
    }
```
+결과
<img src ="https://github.com/steadykyu/TIL/blob/master/spring/captureimg/ch9_result1.PNG" width="100%" height="100%">
+ 서로 다른 프로토타입 빈에 count++ 을 적용시켜 count에 1씩 들어간다.
### 싱글톤 빈에서 프로토타입 빈 사용
```java
@Scope("singleton") //안써도 어차피 싱글톤이긴한데 구별을 위해 작성.
    static class ClientBean {
//        싱글톤 빈 생성후 프로토타입 주입
        private final PrototypeBean prototypeBean;
        @Autowired
        public ClientBean(PrototypeBean prototypeBean){
            this.prototypeBean = prototypeBean;            //생성시점에 주입 x01
        }
        public int logic(){

            prototypeBean.addcount();
            int count = prototypeBean.getCount();
            return count;
        }
    }
 ```
 + 싱글톤 빈 생성후 프로토타입 주입
 + 테스트
 ```java
 @Test
    void singletonClientUsePrototype(){
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class); //둘다 빈에 등록

        ClientBean clientBean1 = ac.getBean(ClientBean.class);
        int count1 = clientBean1.logic();
        assertThat(count1).isEqualTo(1);

        ClientBean clientBean2 = ac.getBean(ClientBean.class);
        int count2 = clientBean2.logic();
        assertThat(count2).isEqualTo(2);
    }
 ```
 > 헷갈리면 pt 그림 참고
 1. new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class); 를 통해 ClientBean를 만든다.
 2. 그리고 이때 생성자 주입으로 PrototypeBean이 주입된다.
 3. ClientBean은 싱글톤이기 때문에 clientBean1에서 요청하나 clientBean2에서 요청하나 같은 ClientBean 으로 간다.
 4. 두 참조변수는 logic()메서드는 공유하는 ClientBean안에 대입되 있는 PrototypeBean에게 addcount()를 한다.
 5. 이전의 PrototypeBean들은 DI 컨테이너에 존재하여, 클라의 요청에 따라 DI 주입을 하고 각각 객체를 만들었다.
 6. 그러나 이번 case는 ClientBean이 생성될때 생성자로 주입을 하고 있기때문에, 새로운 ClientBean이 생성되어야만 PrototypeBean이 새로 생성될것이다.
 7. 즉 주입 시점(생성자주입)에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다(참조변수) 새로 생성되는 것이 아니다!
 8. 그러므로 count1 = 1 , count2 =2를 가진다.

## 프로타타입 스코프-싱글톤 빈과 함께 사용시 Provider로 문제 해결
### 1. 문제해결을 위해 스프링 컨테이너에 직접 요청할 수 있을 것이다.
```java
static class ClientBean {
       @Autowired
       private ApplicationContext ac;
       public int logic() {
           PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class); // 스프링컨테이너에 요청.
           prototypeBean.addCount();
           int count = prototypeBean.getCount();
           return count;
       }
 }
```
+ logic()을 부를때마다 스프링컨테이너에 요청해서 프로토 타입을 만들 수 있다.
+ 의존관계를 외부에서 주입(DI) 받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup (DL) 의존관계 조회(탐색) 이라한다.
+ 그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.
### 2.ObjectFactory, ObjectProvider
+ 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다. 참고로
+ 과거에는 ObjectFactory 가 있었는데, 여기에 **편의 기능을 추가한** 상속(자식)관계의 ObjectProvider가 만들어졌다.
+ 추가된 편의 기능 : 상속, 옵션, 스트림 처리등
```java
static class ClientBean {
   @Autowired
   private ObjectProvider<PrototypeBean> prototypeBeanProvider;
   public int logic() {
      PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
      prototypeBean.addCount();
      int count = prototypeBean.getCount();
      return count;
    }
}
```
+ 실행결과로 count1 =1 , count2 =1 이 나온다. 즉 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
+ ObjectProvider 의 getObject() 를 호출하면 내부에서는 **스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL방식)**
+ 이전에는 싱글톤빈에 프로토타입빈이 들어있어서 문제였지만, 이렇게 하면 프로토타입 빈에 찾아가서 참조할 수 있게 된다.(즉 프로토타입 객체안의 값 사용가능!)
> 특징
+ 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
+ 별도의 라이브러리가 필요없다.
### 3. JSR-330 Provider
+  JSR-330 자바 표준을 사용하는 방법으로, 내가 직접 가서 javax.inject:javax.inject:1 라이브러리를 gradle에 추가해야 한다.(검색이안됨)
```java
package javax.inject;
public interface Provider<T> {
 T get();
}
```
Provider의 모습
```java
static class ClientBean {
  @Autowired
  private Provider<PrototypeBean> provider;
  public int logic() {
     PrototypeBean prototypeBean = provider.get();
     prototypeBean.addCount();
     int count = prototypeBean.getCount();
     return count;
   }
}
```
+ 방식은 ObjectProvider와 다르지 않다.
+ provider 의 get() 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
+ **자바 표준**이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
> 특징
+ get() 메서드 하나만 존재한다.
+ 별도의 라이브러리가 필요하다.
+ 자바 표준이므로 스프링이 아닌 **다른 컨테이너에서도 사용할 수 있다.**

### 참고
+ 열심히 했지만 프로토타입빈은 생각보다 자주 사용되지 않는다.
+ 상황에 따라 ObjectProvider와 330 Provider를 사용하면 된다.
## 웹 스코프
### 특징
+ 웹 스코프는 웹 환경에서만 동작한다.
+ 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.

### 종류
+ request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
+ session: HTTP Session과 동일한 생명주기를 가지는 스코프
+ application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프
+ websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프
## request 스코프 예제 만들기
+ 가장 쉬운 request 예제를 만들어 보자. 어차피 동작방식은 비슷하다.
```
implementation 'org.springframework.boot:spring-boot-starter-web'
```
+ 위의 web 라이브러리를 추가해주자.
+ 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다. 이럴때 사용하기 딱 좋은것이 바로 request 스코프이다.
```
[d06b992f...] request scope bean create
[d06b992f...][http://localhost:8080/log-demo] controller test
[d06b992f...][http://localhost:8080/log-demo] service id = testId
[d06b992f...] request scope bean close
```
+ 다음과 같이 로그가 남도록 request 스코프를 활용해서 추가 기능을 개발해보자.
+ 기대하는 공통 포멧: [UUID][requestURL] {message}
+ UUID를 사용해서 HTTP 요청을 구분하자.
+ requestURL 정보도 추가로 넣어서 어떤 URL을 요청해서 남은 로그인지 확인하자
****
```java
@Component
@Scope(value = "request")
public class MyLogger {
    private String uuid;
    private String requestURL;

    public void setRequestURL(String requestURL) {
        this.requestURL = requestURL;
    }

    public void log(String message){
        System.out.println("[" + uuid + "]" + "[" + requestURL + "]" +  message );
    }

    @PostConstruct
    public void init(){  //초기값
        uuid = UUID.randomUUID().toString();
        System.out.println("[" + uuid + "] request scope bean create:" + this);
    }
    @PreDestroy
    public void close(){  //종료직전 호출
        System.out.println("[" + uuid + "] request scope bean close:" + this);
    }
}
```
+ 로그를 출력하기 위한 MyLogger 클래스이다
+ @Scope(value = "request") 를 사용해서 request 스코프로 지정했다. 이제 이 빈은 HTTP 요청 당 하나씩 생성되고, HTTP 요청이 끝나는 시점에 소멸된다.
+ 이 빈이 생성되는 시점에 자동으로 @PostConstruct 초기화 메서드를 사용해서 HTTP끼리 구분 할수 있도록 uuid를 생성해서 저장해둔다.
+ requestURL 은 이 빈이 생성되는 시점에는 알 수 없으므로, 외부에서 setter로 입력 받는다.
****
```java
@Controller
@RequiredArgsConstructor  // 자동 생성자 주입 애노테이션
public class LogDemoController {
    private final LogDemoService logDemoService;  
    private final MyLogger myLogger;               // 가독성을 위해 필드 주입함
    @RequestMapping("log-demo")                    // 주소 매핑
    @ResponseBody
    public String logDemo(HttpServletRequest request) {
       String requestURL = request.getRequestURL().toString(); //고객이 어떤 url로 요청했는지 알 수 있음. http 시작요청
       myLogger.setRequestURL(requestURL);
       myLogger.log("controller test");
       logDemoService.logic("testId");
    return "OK";
 }
}
```
+ 로거가 잘 작동하는지 확인하는 테스트용 컨트롤러다.
****
```java
@Service
@RequiredArgsConstructor
public class LogDemoService {
   private final MyLogger myLogger;
   public void logic(String id) {
   myLogger.log("service id = " + id);
 }
}
```
+ 비즈니스 로직이 있는 서비스 계층에서도 로그를 출력해보자.
```
여기서 중요한점이 있다. request scope를 사용하지 않고 파라미터로 이 모든 정보(UUID, requestURL)계층에 넘긴다면, 파라미터가 많아서 지저분해진다.
더 문제는 requestURL 같은 웹과 관련된 정보가 웹과 관련없는 서비스 계층까지 넘어가게 된다. 웹과 관련된 부분은 컨트롤러까지만 사용해야 한다. 
서비스계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.
```
+ request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고, MyLogger의 멤버변수에 저장해서 코드와 계층을 깔끔하게 유지할 수 있다.
실행 결과
```
Error creating bean with name 'myLogger': Scope 'request' is not active for the 
current thread; consider defining a scoped proxy for this bean if you intend to 
refer to it from a singleton;
```
+ web이 만들어 지지않았다. 왜일까
+ 먼저 @RequiredArgsConstructor를 통해 필드 주입을 할 것이다. 그러나 request scope이기 때문에 아직 request 스코프 빈은 생성되지 않았다.
+ request 스코프 빈이 생성되려면 logDemo 메소드안의 request.getRequestURL() 가 실행되어 HTTP가 실행되어야 하는데 그 전에 필드 주입을 하여 문제가 발생한다.
## 스코프와 Provider
### 1. 해결방안1-Provider
```java
@Controller
@RequiredArgsConstructor
public class LogDemoController {
    private final LogDemoService logDemoService;
    private final ObjectProvider<MyLogger> myLoggerProvider;  // ObjectProvider<> 사용
    @RequestMapping("log-demo")
    @ResponseBody
    public String logDemo(HttpServletRequest request) {
       String requestURL = request.getRequestURL().toString();// HTTP는 요청 진행중
       MyLogger myLogger = myLoggerProvider.getObject();      // 이때 컨테이너에 요청하여 request 빈이 생성.
       myLogger.setRequestURL(requestURL);
       myLogger.log("controller test");
       logDemoService.logic("testId");
       return "OK";
 }
}
--------------------------------------
@Service
@RequiredArgsConstructor
public class LogDemoService {
 private final ObjectProvider<MyLogger> myLoggerProvider;
 public void logic(String id) {
    MyLogger myLogger = myLoggerProvider.getObject();          // Collection과 같은 request 빈이 반환
    myLogger.log("service id = " + id);
 }
}
```
실행결과
```
[d06b992f...] request scope bean create                             //초기값
[d06b992f...][http://localhost:8080/log-demo] controller test       //log메서드
[d06b992f...][http://localhost:8080/log-demo] service id = testId   //log메서드
[d06b992f...] request scope bean close                              //종료시점
```
+ ObjectProvider 덕분에 ObjectProvider.getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.(정확히는 스프링 컨테이너에 요청을 지연)
+ ObjectProvider.getObject() 를 호출하시는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.
+ ObjectProvider.getObject() 를 LogDemoController , LogDemoService 에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이므로 같은 스프링 빈이 반환된다!
## 스코프와 프록시
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {}
```
+ 이전 맨처음 상태에서 proxyMode만 붙여주자.
+ 적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS 를 선택
+ 적용 대상이 인터페이스면 INTERFACES 를 선택
+ 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고, HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.
+ 실행결과가 Provider를 쓴것과 같다. 어떤 원리일까

### 웹 스코프와 프록시 동작 원리
+ myLogger.getClass()로 주입된 myLogger를 확인해보자.
```
myLogger = class hello.core.common.MyLogger$$EnhancerBySpringCGLIB$$b68b726d
```
+ CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
+ myLogger"라는 이름으로 우리가 등록한 순수한 MyLogger 클래스가 아니라, MyLogger$$EnhancerBySpringCGLIB이라는 **가짜 클래스를 필드주입** 시킨 것이다.
+ 이 가짜 클래스는 "ac.getBean("myLogger", MyLogger.class)"로 조회해도 조회된다.
+ 가짜 프록시 객체는 요청이 오면 그때 내부에서 **진짜 빈을 찾아내고 요청하는** 위임 로직이 들어있다.(앞에서 요청받아서 대신처리주는 역할)
+ 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.
+ 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다(다형성)

### 정리
+ 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
+ Provider나  프록시 둘다 웹,프로토타입 이외의 다른곳에서도 사용할 수 있다.
+ 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.

### 주의점 
+ 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야 한다.(필드 값같은 부분들)
+ 이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별하게 사용하면 유지보수하기 어려워진다.
