## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

핵심주제 : 스프링 컨테이너를 왜사용하는걸까?
+ 현재까지의 나의 생각
****
+ App을 만드는데, 좋은객체지향설계로 만들 수 있다.(다형성,OCP, DIP만족시키고, DI를 좀더 편하게 제공)
****
+ BeanFactory 에 있는 빈 조회기능들, 특히 ApplicationContext interface에 있는 부가기능들로 Java App을 제작하는데 도움을 줄 수 있다.
****
+ 다양한 설정 형식을 지원한다.(java 코드로 된 애노테이션 설정 기법에서 , xml을 파일을 통한 설정정보로 교체할 수있다.(굳이 따지자면 다형성)
****
+ 웹사이트는 동시에 오는 요청이 많다. 이에 대해 Bean 컨테이너를 싱글톤패턴으로 만들어 주는 @Configuration을 사용하면 공유하는 객체를 이용하여 메모리 낭비를 줄일 수 있다.
+ @Configuration을 설정정보 클래스(AppConfig.class)에 입력해주면, Bean 컨테이너는 싱글톤 컨테이너로 만들어진다. 
****
+ 스프링빈을 몇천개 만들어야 하는 상황이라면, @Bean을 몇천번 입력해야할 뿐더러 실수가 나올 확률이 클 것이다.
+ 이럴때는 구현체에 @ComponentScan과 @Component, 구현체의 생성자에 @Autowired를 사용하면 스프링이 컨테이너 안에 빈이름과 빈객체을 만들어주고, Autowired룰 방식에 따라 자동으로 DI를 해준다.
+ 그러므로 AppConfig(설정정보)에 작성해야했던 소스코드를 저 두종류의 애노테이션으로 만들 수 있게 된 것이다.
****
+ 위에서 배운 Autowired는 자동으로 DI 작업해주기 때문에 편리함을 주지만, 그렇기 때문에 어떻게 돌아가는지 알고 있어야한다. 
+ 또한 스프링에서 제공하는 기능은 자동으로 돌아가도록, default설정을 유지하여 명확성를 올리자.(스프링 로직 아는 개발자가 보면 코드를 보자 마자 알수 있도록)
+ 기술지원 빈이 필요하거나 다양한 비즈니스로직을 위해 다형성을 사용해야하는 상황이 있다면 Config클래스에 수동적으로 @Bean을 만들어 다른 개발자들이 작업하기 편하도록 할 수 있다.
****
8.
+ App들은 대부분 RDMS 쓰는데 App서버가 올라올 때 미리 DB랑 연결을 맺거나 소켓설정을 할수 있다. 이를 통해 고객요청이 왔을때 미리 DB를 연결로 값을 넣고, 소켓을 열어줄수 있다. 이런 기능이 작동하기 위해서 우리는 객체에 외부 값들에 대한 초기화를 해야한다. 이런 과정에서 빈의 생성 직후 바로 초기화를 하고, 빈이 죽기직전에는 호출을 해줄 수 있는 생성주기 콜백이 필요하다.
+ 객체의 초기화와 종료를 위해서 주로 @PostConstruct, @PreDestroy애노테이션을 사용한다. 하지만 이 둘은 외부 라이브러리를 초기화 해주지 못한다.
+ 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를 사용하자.
****

## 목차

## 빈 스코프란
+ 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.(지금까지 우리가 써온 스코프)
+ 프로토타입: 스프링 컨테이너가 프로토타입 빈의 생성과 의존관계 주입까지만 관여한다. 이후 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
> 웹 관련 스코프
+ request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
+ session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
+ application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.
### 스코프 사용법
```
@Scope("prototype")
@Component
public class HelloBean {}
```
+ 자동등록
```
Scope("prototype")
@Bean
PrototypeBean HelloBean() {
 return new HelloBean();
}
```
+ 수동 등록
## 프로토타입 스코프
+ 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 ***새로운 인스턴스***를 생성해서 반환한다.
+ 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다.
+ 그러므로 종료메서드가 호출되지 않는다. 굳이 조회하려면 클라이언트가 직접 해주어야한다.
+ 만약 프로토타입 빈을 2번 조회한다면, 완전히 다른 두개의 스프링 빈이 생성되고, 초기화도 2번 실행될 것이다.
## 프로토타입 스코프-싱글톤빈과 함께 사용시 문제점
### 프로토타입 빈 직접요청을 여러번 한다면
```java
@Scope("prototype")
    static class PrototypeBean{
        private int count = 0;
        public void addcount(){
            count++;
        }
        public int getCount(){
            return count;
        }
        @PostConstruct
        public void init(){
            // this 하면 나를 찍으므로, 나의 참조값(주소값)을 볼수 있다.
            System.out.println("PrototypeBean.init" + this);
        }
        @PreDestroy
        public void destroy(){
            System.out.println("PrototypeBean.destroy");
        }
    }
```
```java
@Test
    void prototypeFind(){
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        //클라1의 요청
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        prototypeBean1.addcount();
        assertThat(prototypeBean1.getCount()).isEqualTo(1);
        //클라2의 요청
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        prototypeBean2.addcount();
        assertThat(prototypeBean2.getCount()).isEqualTo(1);
    }
```
+결과
result1
+ 서로 다른 프로토타입 빈에 count++ 을 적용시켜 count에 1씩 들어간다.
### 싱글톤 빈에서 프로토타입 빈 사용
```java
@Scope("singleton") //안써도 어차피 싱글톤이긴한데 구별을 위해 작성.
    static class ClientBean {
//        싱글톤 빈 생성후 프로토타입 주입
        private final PrototypeBean prototypeBean;
        @Autowired
        public ClientBean(PrototypeBean prototypeBean){
            this.prototypeBean = prototypeBean;            //생성시점에 주입 x01
        }
        public int logic(){

            prototypeBean.addcount();
            int count = prototypeBean.getCount();
            return count;
        }
    }
 ```
 + 싱글톤 빈 생성후 프로토타입 주입
 + 테스트
 ```java
 @Test
    void singletonClientUsePrototype(){
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class); //둘다 빈에 등록

        ClientBean clientBean1 = ac.getBean(ClientBean.class);
        int count1 = clientBean1.logic();
        assertThat(count1).isEqualTo(1);

        ClientBean clientBean2 = ac.getBean(ClientBean.class);
        int count2 = clientBean2.logic();
        assertThat(count2).isEqualTo(2);
    }
 ```
 > 헷갈리면 pt 그림 참고
 1. new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class); 를 통해 ClientBean를 만든다.
 2. 그리고 이때 생성자 주입으로 PrototypeBean이 주입된다.
 3. ClientBean은 싱글톤이기 때문에 clientBean1에서 요청하나 clientBean2에서 요청하나 같은 ClientBean 으로 간다.
 4. 두 참조변수는 logic()메서드는 공유하는 ClientBean안에 대입되 있는 PrototypeBean에게 addcount()를 한다.
 5. 이전의 PrototypeBean들은 DI 컨테이너에 존재하여, 클라의 요청에 따라 DI 주입을 하고 각각 객체를 만들었다.
 6. 그러나 이번 case는 ClientBean이 생성될때 생성자로 주입을 하고 있기때문에, 새로운 ClientBean이 생성되어야만 PrototypeBean이 새로 생성될것이다.
 7. 즉 주입 시점(생성자주입)에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다(참조변수) 새로 생성되는 것이 아니다!
 8. 그러므로 count1 = 1 , count2 =2를 가진다.
## 프로타타입 스코프-싱글톤 빈과 함께 사용시 Provider로 문제 해결
+ 문제해결을 위해 스프링 컨테이너에 직접 요청할 수 있을 것이다.
```java
static class ClientBean {
       @Autowired
       private ApplicationContext ac;
       public int logic() {
           PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class); // 스프링컨테이너에 요청.
           prototypeBean.addCount();
           int count = prototypeBean.getCount();
           return count;
       }
 }
```
+ logic()을 부를때마다 스프링컨테이너에 요청해서 프로토 타입을 만들 수 있다.
+ 의존관계를 외부에서 주입(DI) 받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup (DL) 의존관계 조회(탐색) 이라한다.
+ 그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.
### ObjectFactory, ObjectProvider
+ 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다. 참고로
과거에는 ObjectFactory 가 있었는데, 여기에 편의 기능을 추가해서 ObjectProvider 가 만들어졌다.
## 웹 스코프
## request 스코프 예제 만들기
## 스코프와 Provider
## 스코프와 프록시
