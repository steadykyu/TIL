## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

핵심주제 : 스프링 컨테이너를 왜사용하는걸까?
+ 현재까지의 나의 생각
****
+ App을 만드는데, 좋은객체지향설계로 만들 수 있다.(다형성,OCP, DIP만족시키고, DI를 좀더 편하게 제공)
****
+ BeanFactory 에 있는 빈 조회기능들, 특히 ApplicationContext interface에 있는 부가기능들로 Java App을 제작하는데 도움을 줄 수 있다.
****
+ 다양한 설정 형식을 지원한다.(java 코드로 된 애노테이션 설정 기법에서 , xml을 파일을 통한 설정정보로 교체할 수있다.(굳이 따지자면 다형성)
****
+ 웹사이트는 동시에 오는 요청이 많다. 이에 대해 Bean 컨테이너를 싱글톤패턴으로 만들어 주는 @Configuration을 사용하면 공유하는 객체를 이용하여 메모리 낭비를 줄일 수 있다.
+ @Configuration을 설정정보 클래스(AppConfig.class)에 입력해주면, Bean 컨테이너는 싱글톤 컨테이너로 만들어진다. 
****
+ 스프링빈을 몇천개 만들어야 하는 상황이라면, @Bean을 몇천번 입력해야할 뿐더러 실수가 나올 확률이 클 것이다.
+ 이럴때는 구현체에 @ComponentScan과 @Component, 구현체의 생성자에 @Autowired를 사용하면 스프링이 컨테이너 안에 빈이름과 빈객체을 만들어주고, Autowired룰 방식에 따라 자동으로 DI를 해준다.
+ 그러므로 AppConfig(설정정보)에 작성해야했던 소스코드를 저 두종류의 애노테이션으로 만들 수 있게 된 것이다.
****
+ 이런 Autowired는 자동으로 DI 작업해주기 때문에 편리함을 주지만, 그렇기 때문에 어떻게 돌아가는지 알고 있어야한다. 또한 스프링에서 제공하는 기능은 자동으로 돌아가도록, default 설정하도록 하여 명확성를 올리고 기술지원 빈이 필요하거나 다양한 비즈니스로직을 위해 다형성을 사용해야하는 상황이 있다면 Config클래스에 수동적으로 @Bean을 만들어 다른 개발자들이 작업하기 편하도록 명확성을 높일 수 있다.
****
8.
+ App들은 대부분 RDMS 쓰는데 App서버가 올라올 때 미리 DB랑 연결을 맺거나 소켓설정을 할수 있다. 이를 통해 고객요청이 왔을때 미리 DB를 연결로 값을 넣고, 소켓을 열어줄수 있다. 이런 기능이 작동하기 위해서 우리는 객체에 외부 값들에 대한 초기화를 해야한다. 이런 과정에서 빈의 생성 직후 바로 초기화를 하고, 빈이 죽기직전에는 호출을 해줄 수 있는 생성주기 콜백이 필요하다.
+ 객체의 초기화와 종료를 위해서 주로 @PostConstruct, @PreDestroy애노테이션을 사용한다. 하지만 이 둘은 외부 라이브러리를 초기화 해주지 못한다.
+ 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를 사용하자.

## 목차

## 빈 생명주기 콜백 시작
+ 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.
+ 그러므로 빈이 생성되거나 죽기직전에 초기화 하고 종료작업을 하는 기능을 예제로 알아보자.
****
+ 간단하게 외부 네트워크에 미리 연결하는 객체를 하나 생성한다고 가정해보자. 실제로 네트워크에 연결하는 것은 아니고, 단순히 문자만 출력하도록 했다.
+ 이 NetworkClient는 애플리케이션 시작 시점에 connect() 를 호출해서 연결을 맺어두어야 하고, 애플리케이션이 종료되면 disConnect() 를 호출해서 연결을 끊어야 한다.
```java 
public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
        connect();
        call("초기화 연결 메시지");
    }

    public void setUrl(String url){
        this.url = url;
    }

    //서비스 시작 호출
    public void connect(){
        System.out.println("connect:" + url);
    }

    public void call(String message){
        System.out.println("call: " + url + " message = " + message);
    }

    //서비스 종료시 호출
    public void disconnect() {
        System.out.println("close " + url);

    }
}
```
```java
public class BeanLifeCycleTest {
    @Test
    public void lifeCycleTest(){
        // AnnotationConfigApplicationContext 보다 상위 인터페이스인 ConfigurableApplicationContext
        // ApplicationContext의 자식인터페이스이긴하다.
        ConfigurableApplicationContext ac = new AnnotationConfigApplicationContext(LifeCycleConfig.class);
        NetworkClient client = ac.getBean(NetworkClient.class);
        ac.close();
    }
    @Configuration
    static class LifeCycleConfig{
        @Bean
        public NetworkClient networkClient(){
            NetworkClient networkClient = new NetworkClient();
            networkClient.setUrl("http://hello-spring.dev");
            return networkClient;
        }
    }
}
}
```
+ 설정클래스 LifeCycleConfig 과 테스트 코드
+ 결과
```
생성자 호출, url = null
connect: null
call: null message = 초기화 연결 메시지
```
+ 객체를 생성하는 단계에는 url이 없고, 객체를 생성한 다음에 외부에서 수정자 주입을 통해서 setUrl() 이 호출되어야 url이 값이 존재하게 된다. 그러므로 connect, call 은 null이 뜬다. 
+ setter 주입하고 객체만들면 된도 생각할 수 있다. 그러나 실무에서는 객체를 만들고 **외부 값**을 주입해야하는 일들이 발생한다.
### 스프링 빈의 라이프 사이클
+ 객체 생성 -> 의존관계 주입
+ 물론 생정자주입을 하면 객체 생성과 동시에 의존관계 주입이 일어난다.
+ 그럼 생성자 주입으로 하지 왜 setter주입으로 할까? 그전에 초기화를 알아보자.

#### 초기화
+ 어떤 작업(우리예시라면 네트워크연결)을 하기전에 객체에 필요한 값들(객체 내부에서의 값, 외부에서 들어온값)이 잘 들어가있는 상태.
+ 그러므로 스프링은 의존관계 주입이 완료되면 스프링 빈에게 **콜백 메서드**를 통해서 **초기화 시점을 알려주는** 다양한 기능을 제공한다. 
+ 또한 스프링은 스프링 컨테이너가 종료되기 직전에 **소멸 콜백**을 준다.
> 스프링 빈의 라이프사이클
+ 스프링 컨테이너 생성 &rarr; 스프링 빈 생성 &rarr; 의존관계 주입 &rarr; 초기화 콜백 &rarr; 사용 &rarr; 소멸전 콜백 &rarr; 스프링 종료

> 그래서 왜 초기화랑 생성자 주입을 분리해야하는걸까?
+ 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.
+ 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행
+ 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다(SRP원칙)
+ **즉 코드에서 생성자 주입하는 책임과 connect,call을 통한 외부네트워크와의 연결을 수행하는 과정은 명확하게 나누는 것이 좋다.**
+ 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

## 1. 인터페이스 InitializingBean, DisposableBean
```java
public class NetworkClient implements InitializingBean, DisposableBean {
      private String url;
      public NetworkClient() {
          System.out.println("생성자 호출, url = " + url);
 }
.............
       @Override
       public void afterPropertiesSet() throws Exception {
       connect();
       call("초기화 연결 메시지");
       }
       @Override
       public void destroy() throws Exception {
       disConnect();
 }
}
```
```java
public class BeanLifeCycleTest {
    @Test
    public void lifeCycleTest(){
        ConfigurableApplicationContext ac = new AnnotationConfigApplicationContext(LifeCycleConfig.class);
        NetworkClient client = ac.getBean(NetworkClient.class);
        ac.close();
    }
    @Configuration
    static class LifeCycleConfig{
        @Bean
        public NetworkClient networkClient(){
            NetworkClient networkClient = new NetworkClient();
            networkClient.setUrl("http://hello-spring.dev");
            return networkClient;
        }
    }
}
}
```
+ 출력결과
```
생성자 호출, url = null
NetworkClient.afterPropertiesSet
connect: http://hello-spring.dev
call: http://hello-spring.dev message = 초기화 연결 메시지 
13:24:49.043 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing NetworkClient.destroy
close + http://hello-spring.dev
```
+ InitializingBean, DisposableBean을 상속받고 , 구현메서드를 작성해주면 된다.
+ new AnnotationConfigApplicationContext(LifeCycleConfig.class) 로 (스프링, 빈 컨테이너 생성 &arr; DI &arr; afterPropertiesSet()호출) 이 발생한다.
+ ac.close(); 직전에 destroy()가 호출된다.
+ 아래서 추가로 배울 기능들도 이와 같은 로직이지만, 코드 작성을 더 편하게 해주고 더많은 기능들을 하는 것 뿐이다.

### 초기화, 소멸 인터페이스 단점
+ 해당 코드(NetworkClient)가 스프링 전용 인터페이스에 의존한다.
+ 초기화, 소멸 메서드의 이름을 변경할 수 없다.
+ 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.

## 빈 등록 초기화,소멸 메서드 지정
***설정 정보***에 @Bean(initMethod = "init", destroyMethod = "close") 처럼 초기화, 소멸 메서드를 지정할 수 있다.
```java
public class NetworkClient {
............
      public void init() {
       System.out.println("NetworkClient.init");
       connect();
       call("초기화 연결 메시지");
      }
      public void close() {
       System.out.println("NetworkClient.close");
       disConnect();
      }
}
```
+ 초기화, 소멸메서드를 만든다.
```java
@Configuration
static class LifeCycleConfig {
       @Bean(initMethod = "init", destroyMethod = "close")
       public NetworkClient networkClient() {
       NetworkClient networkClient = new NetworkClient();
       networkClient.setUrl("http://hello-spring.dev");
       return networkClient;
 }
```
+ @Bean에 각각 알맞게 옵션값을 넣어준다.
+ 결과 위와 동일
### 설정 정보 사용 특징
+ 메서드 이름을 자유롭게 줄 수 있다.
+ 스프링 빈이 스프링 코드에 의존하지 않는다.
+ 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.

### 종료 메서드 추론
+ @Bean의 destroyMethod 속성에는 기본값이 (inferred) (추론)으로 등록되어 있다.
+ 이 추론 기능은 대부분의 라이브러리들이 가진 종료메서드 "close" , "shutdown" 라는 이름의 메서드를 자동으로 호출해준다.
+ 따라서 종료메서드를 따로 적어주지 않아도 잘 작동할 때가 많다.
+ 추론 기능을 사용하기 싫으면 destroyMethod="" 으로 지정한다.

## 애노테이션 @PostConstruct, @PreDestroy
```java
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
public class NetworkClient {
    ........

    @PostConstruct
     public void init() {
       System.out.println("NetworkClient.init");
       connect();
       call("초기화 연결 메시지");
     }
     @PreDestroy
     public void close() {
       System.out.println("NetworkClient.close");
       disConnect();
     }
}
```
+ 초기화, 종료할 메서드 위에 애노테이션을 붙여준다.
```java
@Configuration
static class LifeCycleConfig {
   @Bean
   public NetworkClient networkClient() {
       NetworkClient networkClient = new NetworkClient();
       networkClient.setUrl("http://hello-spring.dev");
       return networkClient;
 }
}
```
+ @Bean만 추가
+ @PostConstruct , @PreDestroy 이 두 애노테이션을 사용하면 가장 편리하게 초기화와 종료를 실행할 수 있다

### @PostConstruct, @PreDestroy 애노테이션 특징
+ 최신 스프링이 권장하는 방법으로 컴포넌트 스캔과 잘 어울린다.
+ 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 즉 자바표준이기 때문에, 스프링이 아닌 다른 컨테이너에서 동작한다.
+ 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 기능을 사용하자.


## 최종정리
+ @PostConstruct, @PreDestroy 애노테이션을 사용하자
+ 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를 사용하자.
