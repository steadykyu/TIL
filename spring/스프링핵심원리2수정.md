## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)

## 목차

## 프로젝트 생성
+ 개발환경 설정으로, 새롭게 프로젝트를 하게 되거나 다시 공부할경우 참고하자.

## 비즈니스 요구사항과 설계
+ 비즈니스 요구 사항 요약
```java
+ 회원 , 주문, 할인 정책이 존재하지만 할인정책과 저장소는 아직 미확정 상태이다.
+ 우리는 정책이 결정될때까지 무기한으로 기다릴수 없다. 
+ 그러나 걱정하지말자. 객체 지향설계 방법을 통해 인터페이스를 만들고 구현체를 갈아 끼울수 있도록 설계하면 된다.
```
## 회원 도메인 설계
### 1. 회원 도메인 협력 관계
  - 기획자들을 이해시킬수 있는 설계그림
  - 클라이언트, 회원서비스, 회원 저장소의 역할에 대해 알 수 있다.
### 2. 회원 클래스 다이어 그램(정적)
  - **서버가 실행되지 않은 상태**로 보는 인터페이스와 클래스의 상태이다
  - 정적인 인터페이스와 클래스만 나타내므로 정적 다이어그램이다.
### 3. 회원 객체 다이어 그램(동적) 
  - 실제 객체간의 참조관계에 대해 그려놓은 다이어그램
  - 실제 런을 돌려 서버가 실행되어야 객체들이 생성될 것이다. 그러므로 동적 다이어그램이라도 불린다.

## 회원 도메인 개발
+ Grade : 회원등급을 enum으로 생성.(Grade안의 BASIC, VIP 외의 값은 쓰일수 없다.)
+ Member 클래스 : 회원 객체 
+ MemberService : 회원가입을 하면 DB에 고객정보를 전달하고, 고객id를 통해 DB에 존재하는 고객객체를 꺼내주는 역할을 지닌 인터페이스 생성
+ MemberServiceImpl : MS를 구현한 객체 
+ MemberRepository : 고객정보를 DB에 저장하고, 고객 id를 통해 DB에 존재하는 고객객체를 찾아주는 역할을 지닌 인터페이스 생성 
+ MemoryMemberRepository: MR를 구현한 객체 참고사항

## 회원 도메인 실행과 테스트
+ 위의 회원 객체 다이어그램과 같이 인스턴스 참고그림이 잘 만들어졌는지 런타임을 통해 테스트해보자.
+ 우리가 생성한 Member와 MS를 통해 MR에서 꺼내온 Member같은지 비교하면된다.
+ 우리는 테스트를 main에서 출력해서 할수도 있고, JUnit test프레임워크를 이용할 수 있다.
### 1. main함수에서 하기.
+ Memberapp 클래스를 만들고 main 함수안에서 작업한다.
### 2. JUnit test프레임워크
+ Test directory 아래 test 프레임워크를 사용한다.
+ org.assertj.core.api.Assertions 을 사용해서 비교한다.

+ 현재까지의 상황과 코드들은 DIP를 지키고 있지않다.
+ (MSI의)의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음
+ 주문까지 만들고나서 문제점과 해결 방안을 설명

## 주문과 할인 도메인 설계
### 1. 주문 도메인 전체
  + 실세계의 역할과 구현이 담기는것과 같이 그림을 작성하자.
### 2. 주문 도메인 클래스 다이어그램
  + 역할과 구현 설계에 따른 인터페이스와 구현객체를 보여주고 있다.
### 3. 주문 도메인 객체 다이어그램1,2
1. 메모리 DB, 정액할인정책
2. DB저장소, 정률 할인정책
그림을보면 주문서비스를 변경하지 않고도 역할들이 협력 관계를 그대로 재사용 하는 모습을 볼 수 있다.

## 주문과 할인 도메인 개발
일단은 메모리 회원 리포지토리와, 고정 금액 할인 정책을 구현체로 생성했다.
아래 코드는 객체 다이어그램과 같이 OSI 와 MMR, FDP의 관계를 보여주고있다.
```java
public class OrderServiceImpl implements OrderService {
 private final MemberRepository memberRepository = newMemoryMemberRepository();
 private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
 //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
 .........
```
+ Order : 주문객체
+ DiscountPolicy : 멤버의 등급에 따라 할인액을 부여하는 인터페이스
+ FixDiscountPolicy : DiscountPolicy역할의 구현체들 중 정액할인구현체 
+ OrderService : DB에 있는 member객체를 가져와 VIP여부에 따라 할인액을 구하고, 그 데이터들로 주문을 생성하는 역할
+ OrderServiceImpl : 구현체
+ 참고 : 이때 os 입장에서는 할인정책에 대해 모르고, 만약 할인 정책이 바뀌더라도 할인정책의 구현체만 바꿔주면 된다.(NEW FDP() -> NEW RDP())
+ SRP 를 잘 지킨 설계이다.

## 주문 할인 도메인 실행과 테스트
회원이 생기고, 회원이 주문생성을 하면 알맞은 할인 금액(1000)이 출력되는지 테스트 해보자.
### 1. OrderApp의 main 메서드에서 작업.
Order 객체에서 생성한 toString()으로 인해, Order객체의 필드값들이 나오고 있다.
### 2. 주문과 할인 정책 테스트
우리는 왜 이렇게 단위로 테스트할까? - 스프링 부트가 섞인, 여러라이브러리가 섞인 Core에 테스트하면 테스트시간이 너무길어지고, 알기도 힘들다.
어떻게 활용할까? - 자주 단위테스트를 하고 기록해두어 오류수정에 용이하게 만들어야한다.

## 정리
+ 우리는 역할과 구현을 나누는 다형성을 이용하여, 자바의 인터페이스와 클래스를 사용하여 회원과 주문 도메인을 개발했다.
+ 만약 저장소나 할인정책이 바뀌게 된다면, 각각 구현체만 바꿔주면 되므로 다형성이 형성되고 있다.
+ 근데 과연 이렇게 작성한 코드가 좋은 객체 지향설계 코드일까? 다음 md에서 확인해보자.
