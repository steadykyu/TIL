## 글의 목적
1. 긴 강의내용의 액기스를 모아놓음으로써, 미래의 내가 보기 편하게 하기 위함.
2. 내가 이해하기 어려운 부분을 적어 놓음으로써, 내 머리속에 제대로 지식을 넣기 위함.(weekness)
+ 액기스에 대한 정의
+ 왜 이 기술을 사용하는걸까?(why)
+ 이 기술을 어떻게 활용할 수 있을까?(how)


+ 질문 : 왜 DI를 사용해서 작성해야하는가?
+ 뇌피셜 답안 : 다형성으로 만든 객체지향 설계에 부족한 점을 생성자주입을 통한 DI(의존관계 주입)를 함으로써, OCP원칙, DIP 원칙을 지키게 되고 무엇보다 이런 코드 변경상황이 존재할때(구현체변경상황)이 존재할때 구성영역의 Config만 코드수정하면, 기능영역은 코드수정은 하지않지만 기능을 늘릴수 있다.<br> 즉 주어진 다양한 문제 상황들을 빠른시간에, 협업에 관점에서도 유리하게 해결 할 수 있기에 사용한다고 생각한다.
## 목차



## 새로운 할인정책 개발
+ 이전에 우리는 정액할인(FDP)로 개발했었다. 정책결정이 정률할인(RDP)로 바뀌었다고 한다.
+ 객체지향설계 원칙을 통해 유연하게 설계해보자.
+ DistcountPolicy 인터페이스 : 멤버와 물건 가격에 대하여 알맞은 할인금액을 구하도록하는 역할
+ RateDistcountPolicy로 구현 :  멤버가 VIP라면 10프로 할인해주는 구현체를 만들자.
+ 테스트를 작성하여, 가격값을 넣었을때 할인액이 가격의 10% 인지를 확인하자.

## 새로운 할인정책 적용과 문제점
```java
public class OrderServiceImpl implements OrderService {
// private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
 private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
}
```
+ 할인 정책을 RDP로 바꾸어주었다.
+ 역할과 구현 충실히 분리 -> OK
+ 다형성을 활용하여, 인터페이스와 객체를 분리 -> OK
****
+ **문제점**
+ OCP, DIP같은 객체지향설계원칙을 충실히 준수했다 -> NO
****
+ 어떻게 문제를 해결해야할까?
+ 먼저 DIP 문제 해결을 위해, OSI가 인터페이스에만 의존하도록 바꾸자.
```java
public class OrderServiceImpl implements OrderService {
 //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
 private DiscountPolicy discountPolicy;
}
```
+ 실행하면 인스턴스가 없으므로 당연히 NPE(null pointer exception)가 발생한다.
+ 결국 현재 클라이언트인 OSI에 DP구현객체를 ***주입해줄 누군가***가 있어야한다.

다시 원점으로(FDP가 작동되고 있다고 생각하자) 가서 아래의 절차를 밟고 고민해보자.

## 관심사의 분리
> 잠시 공연을 생각해보자.
> 공연(APP)을 구성하고, 담당배우를 섭외하고(객체생성), 역할에 맞는 배우(인터페이스와 구현체연결)를 지정하는 책임을 담당하는 별도의 공연 기획자 가 필요하다.
> 우리는 AppConfig에게 이 ***기획자의 역할***을 책임지게 할 것이다.
### AppConfig 등장
> AppConfig.class code

```java
public MemberService memberService() {
  return new MemberServiceImpl(new MemoryMemberRepository());
 }
public OrderService orderService() {
   return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
 }
 ```
+ 이전에는 우리가 MSI(구현체)에서 MMR객체를 만들었었다.(OSI에서는 MMR과 FDP를 만들었었음)
+ 이제는 Appconfig에서 구현 객체를 생성하는 부분들을 만든다. = new MSI,new MMR
+ 객체를 생성했으므로 이제 만든 객체를 주입시켜주자. 

### MSI, OSI 생성자 주입
생성자는 객체가 생성할때, 바로실행되며 초기값을 설정해준다.
MemberServiceImpl.class code
```java
public class MemberServiceImpl implements MemberService {
   private final MemberRepository memberRepository;
   public MemberServiceImpl(MemberRepository memberRepository) {
   this.memberRepository = memberRepository;
 }
 ```
+ 생성자 생성과 new MSI(new MMR)를 통해 MMR이 MSI에 주입되고 있다.
### 정리
+ 이제 MSI는 MR에만 의존하고 있다. = DIP 위반해결
+ appConfig 객체는 memoryMemberRepository 객체를 생성하고 그 참조값을 memberServiceImpl를 생성하면서 생성자로 전달한다.
+ MSI 입장에서는 MMR의 의존관계가 주입된다. 이렇게 주입되는 관계를 DI 의존관계주입이라고 한다.
+ 어떤객체를 주입할 지는 오직 외부(AppConfig)에서만 결정하고, MSI는 이제 실행에만 집중하면 된다
+ OSI도 MSI와 같은 로직이나, 주입해야할 객체가 두개이므로 매개변수를 두개 입력해주면 된다.
+ OSI 입장에서는 MMR과 FDP객체의 의존관계가 주입되는 것이다.
## AppConfig 실행
> MemberApp.class code
### 1. main 메서드로 테스트하기.
```java
public static void main(String[] args) {
   AppConfig appConfig = new AppConfig();
   MemberService memberService = appConfig.memberService();
   .............
```
+ Appconfig 객체를 부르면, appConfig참조변수를 통해 메서드(memberService())를 호출할 수 있다.
+ 메서드에서 리턴한 MSI객체를 통해 MS인터페이스에 구현체를 넣어줄 수 있다.
+ (OrderApp main테스트도 마찬가지)

### 2. 테스트 프레임워크에서 테스트하기.
```java
class MemberServiceTest {
   MemberService memberService;
   @BeforeEach
   public void beforeEach() {
   AppConfig appConfig = new AppConfig();
   memberService = appConfig.memberService();
   }
   @Test
   ...............
}
```
+ 테스트코드에서는 @BeforEach를 통해 각 테스트를 실행하기 전에 객체들을 생성시킬 수 있다.
+ 결국 우리는 Appconfig를 통해 객체를 생성하고, 역할에 맞게 객체를 생성자를 통해 주입시켰다.

## AppConfig 리팩터링
현재 AppConfig를 보면 중복이 있고, 역할에 따른 구현이 잘 안보인다.
+ 클래스 다이어그램처럼 깔끔하게 코드도 역할과 구현 정리하고 싶다.
```java
public class AppConfig {
   public MemberService memberService() {
   return new MemberServiceImpl(new MemoryMemberRepository());
   }
   public OrderService orderService() {
   return new OrderServiceImpl(
   new MemoryMemberRepository(),
   new FixDiscountPolicy());
   }
}
```
ctrl alt m을 두번사용하면 리팩토링과 함께 이름설정과 타입을 변경할 수 있다.
```java
public class AppConfig {
 public MemberService memberService() {
  return new MemberServiceImpl(memberRepository());
 }
 public OrderService orderService() {
  return new OrderServiceImpl(memberRepository(),discountPolicy());
 }
 public MemberRepository memberRepository() {
  return new MemoryMemberRepository();
 }
 public DiscountPolicy discountPolicy() {
  return new FixDiscountPolicy();
  //return new RateDiscountPolicy();
 }
}
```
+ 코드중복일 줄일뿐만아니라, code만 봐도 각각의 역할과 구현모습이 그려진다.

## 새로운 구조와 할인 정책 적용
```java
 public DiscountPolicy discountPolicy() {
  //return new FixDiscountPolicy();
  return new RateDiscountPolicy();
```
+ 자 그럼 이제 새로운 구조에 할인 정책을 변경 시켜보도록하자.
+ Appconfig의 등장으로 코드들은 이제 구성영역과 사용영역으로 나뉘게 된다.
+ 그저 구성영역(Appconfig)에 있는 코드만 변경시키면 된다.
+ 기능을 RatePoilcy로 바꿨지만(기능확장), 클라이언트 코드를 변경시키지 않았다.
+ 이제 OCP가 지켜지고 있는 모습을 볼수있다.

## 전체흐름정리

## 좋은 객체 지향 설계의 5가지 원칙
우리의 작업은 3가지원칙을 적용하고 있다.
### 1. SRP
+ 이전의 코드는 클라이언트 객체가(MSI) 구현객체(MMR)를 생성, 연결, 실행해야하는 다양한 책임을 가지고 있었다.
+ 이제는 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당하고 클라이언트 객체는 실행하는 책임만 담당한다.
+ (OSI도 마찬가지)
### 2. DIP
+ 이전의 코드는 MSI가 인터페이스에 의존할 뿐만아니라, MMR 객체에도 의존하고 있었다.(의존은 알고있다, 내부코드에 있다로 해석하면된다.)
+ 인터페이스에만 의존하게 만들었더니, 인스턴스 객체가 없었다.
+ AppConfig가 MMR 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트코드(MSI)에 의존관계를 주입했다. 
+ 이렇게해서 DIP 원칙을 따르면서 문제도 해결했다.
+ (OSI도 마찬가지)
### 3. OCP
+ AppConfig가 의존관계를 FDP -> RDP 로 변경해서 클라이언트 코드에 주입하므로 
+ AppConfig코드만 수정할뿐, 클라이언트 코드(OSI)는 변경하지 않아도 된다.

### IOC, DI, 그리고 컨테이너
+ 기존프로그램은 클라이언트 객체가 객체생성, 연결, 실행 하면서 모든 흐름을 제어했다.
+ AppConfig의 등장 이후로는 객체생성, 객체연결(주입), 심지어 클라이언트 객체생성(MSI,OSI)까지 AppConfig가 제어흐름을 가지고 있다.
+ 다음과 같이 프로그램의 제어 흐름을 해당 객체에서 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다

### 프레임워크 vs 라이브러리
프레임 워크 : 내가 작성한 코드를 프레임워크가 제어하고, 대신 실행
라이브러리 : 내가 작성한 코드의 제어의 흐름을 내가 담당함.
+ Jnit 프레임워크 : 나는 로직만 만들었는데 beforeEach를 먼저 실행하고 @test를 실행함. 제어권을 JUit framework가 가지고 있기 때문이다.
+ Json으로 바꾸는 라이브러리 : 만약 자바객체를 라이브러리를 가져와서 json으로 바꿧다고하자. 바꾼 결과값은 결국 내가 제어함.

### 의존관계 주입(DI)
+ 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다

#### 정적인 클래스 의존관계
+ 정적인 의존관계는 애플리케이션을 실행하지 않아도 import 코드만 보고도 분석할 수 있다. 클래스 다이어그램을 생각해보자.
+ 이때 의존관계는 알수는 있지만, 어떤 구현체가 들어올 것인지는 알 수 없다.

#### 동적인 클래스 의존관계
+ 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
+ 객체 다이어그램을 생각해보자.
+ 이때 의존관계 주입(DI)을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.(ex 정액객체-> 정률객체)
#### 정리
의존관계 주입(DI)을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
주의 : 의존관계와 의존관계 주입은 다른 개념이다. 자꾸 내가 동일시하려함.

### IOC 컨테이너, DI 컨테이너
AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 한다

## 스프링으로 전환하기
### AppConfig 스프링으로 전환하기
```java
@Configuration
public class AppConfig {
   @Bean
   public MemberService memberService() {
   return new MemberServiceImpl(memberRepository());
   }
   .........
```
+ AppConfig에 설정을 구성한다는 뜻의 @Configuration 
+ 각 메서드에 @Bean 을 붙여준다. 이렇게 하면 메서드들을 스프링 컨테이너에 스프링 빈으로 등록

### MemberApp에 스프링 컨테이너 적용
```java
public class MemberApp {
 public static void main(String[] args) {
 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
 MemberService memberService =applicationContext.getBean("memberService", MemberService.class); //메서드이름, 타입
```
+ 이전에는 개발자가 필요한 객체를 AppConfig사용한 객체를 직접만들어서 DI를 했다.
+ 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾고 DI를 해준다.
+ 스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾을 수 있다.
+ 괜히 코드만 더 복잡해진거 같은데, 굳이 왜 사용하는걸까? 스프링핵심원리4를 보도록하자.
