***다음의 내용은 김영한님의 스프링 입문강의를 듣고, 저만의 방식으로 정리한 자료이다.***<br>
***김영한님이 주신 강의자료에 저만의 생각을 써 넣는 방식으로 진행했다.***<br>
***문서와 중복되는 내용은 많이 제거했으니, 강의자료와 함께 읽으면서 코드를 쳐보는게 좋다.***<br>
***너무 어려운 개념들이라 생략된 부분들도 많고 넘어가지만, 추후에 심화강의들을 또 들어보고 정리하면 정리될 것이라고 생각한다***<br>



## 프로젝트 환경설정
### 프로젝트 생성을 위한 준비물

### 스프링 부트 스타터 사이트로 이동하여, 스프링 프로젝트 생성
  + https://start.spring.io/
  + 문서 내용에 맞도록 프로젝트 선택( ADD Dependencies 에서 필요한 라이브러리 추가) 후 generate
  + Intellij를 열고 open하여 spring.io 에서 받은 디렉토리를 지정해준다.
  + Intellij 안 build.gradle를 보면 Grandle에 대한 설정 값이 나옴
    
### IntelliJ Gradle 대신에 자바 직접 실행
  + 실행 속도를 빠르게 하기 위해 작업.
      
### IntelliJ 에서 단축키를 확실하게 검색하는 법
![shortCutKey](https://user-images.githubusercontent.com/48472652/153123511-df9a43d3-851c-4fb0-a33a-c4c65c3408d3.JPG)

## 라이브러리 살펴보기
  + External Libraries 에서 확인
  + 자세한 라이브러리 내용은 문서 or 검색

### View 환경설정
  + 링크를 타고 들어가서, welcome을 검색해보면 welcome page를 만드는 원서가 나온다.
  + static 디렉토리안에 index.html을 추가해보자.
  + <body> 안의 Hello를 출력하고, home 디렉토리/hello 링크를 제작하고 그안에 hello를 쓴다.(후자는 안열림)
  + 지금은 그냥 static 한 값 자체를 넣어준 경우이다.
  
### thymeleaf 템플릿 엔진
  + HelloController 클래스를 만들고, templates 디렉토리에 hello.html을 추가한다.
  + web app에서 /hello가 들어오면 GetMapping("hello")를 확인한 후 아래 메서드를 실행시킨다.
  + return 값인 "hello"와 모델을 가지고 viewResolver 가 resourse/templates/hello.html를 찾아주고 처리한다.
  + 웹이 열린다.
  
### 빌드하고 실행하기
https://violetboralee.medium.com/intellij-idea%EC%99%80-git-bash-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0-63e8216aa7de
  + git bash로 terminal를 사용하도록, 변경함.
  + cd .. : 상위 디렉토리 가기(그냥 cd 하면 홈디렉터리로 온다.)
  + ./gradlew clean : gradle 지우면서 디렉토리내의 bulid 폴더가 사라짐
  + ls -arlth : -arlth는 모든 파일, 폴더를 시간 역순으로 출력
  
## 스프링 웹 개발 기초
  + 정적 컨텐츠 : 파일 그자체를 고객에게 주는것(html)

  + MVC : model, view, controller 패턴으로 서버에서 제공하는 동적 컨텐츠 이다.

  + API : 서버와 클라의 약속으로 요즘은 IOS나 안드로이드 개발자와 협업을 할때, api로 json으로 파일을 주면 
  앞의 개발자들이 데이터나 파일을 받고 화면을 만든다.
  
### 정적 컨텐츠
  + 스프링 컨테이너안 hello-static 관련 컨트롤러가 없을때, 찾아서 html 값 그대로를 출력시킨다.
  
### MVC와 템플릿 엔진
  + View : 화면그리는데 모든 역량을 집중
  + M, C : 비즈니스 로직이나, 내부적 처리에 집중
  + helloMvc 메서드 생성. hello-template.html 생성
  + ctrl + p : 파라미터 정보 옵션을 준다.(helloMvc메서드에서 @RequestParam에서 써보기)
    boolean option 에서 default가 required() = true이면 값을 꼭 넘겨주어야 한다는 의미이다.
  + Model attributevalue에 변수값을 넣어줌으로써, 동적인 web이 만들어진다.
  + html에서 th: 는 thymeleaf engine / hello! empty는 껍데기 값이다.
  + ${name} 은 Model key값중 name을 찾고, 그 안의 value를 꺼내오라는 의미이다.
  + http://localhost:8080/hello-mvc?name=spring 처럼 ? 이후에 파라미터 값을 넣어줄 수 있다.

### API
  #### @ResponseBody 문자 반환
  + viewResolver를 사용하지 않고, 문자내용을 직접반환.
  + template을 만들지 않고 출력해버린 모습
  #### @ResponseBody 객체 반환
  + template을 만들지 않고 출력해버린 모습
  + ctrl + shift + enter 코드자동완성
  + alt + insert : generate ex) getter,setter, constructor 등등
  + 참고 : xml이 많이 쓰이다가, 현재는 json 방식으로 통일이 되었다.
  + spring은 객체 리턴시 default로 json 리턴방식을 따른다.
  + 추가 공부 : Json
  
## 회원 관리 예제 - 백엔드개발
### 비즈니스 요구사항 정리
  
### 회원 도메인과 리포지토리 만들기
#### 회원객체
#### 회원 리포지토리 인터페이스
#### 회원 리포지토리 메모리 구현체
  + Optional<>: 매개변수가 null로 올때, optional이 감싸서 처리해준다.
  + alt + enter : option enter로  option에 뜬 내용을 확인가능
  + sequence는 0,1,2 같은 key값을 생성을 위해 입력.
  + 추가공부 : 동시성문제..? 
  + Optional.ofNullable : null이 들어오면 optional로 감싸서 출력함
  + .filter(람다식)
  + .findAny();  하나라도 찾으면 리턴<br>끝까지 돌려도 없으면, optional에 null이 포함된 채로 리턴
  + 잘 구현되고 있는지 확인을 위해 TestCase를 작성해야한다.
  + 개인적인 추가공부 : stream()
  
### 회원 리포지토리 테스트 케이스 작성
  #### 회원 리포지토리 메모리 구현체 테스트
  + 내가 새로 만든객체에서 이름을 정해준 것을 repository에 넣고
  + repository에서 찾아내온 값이 일치하면 무사히 테스트 통과일 것이다!
  + Junit의 Assertion 또는 assertj의 Assertion으로 비교가능. 후자를 더 선호.(가독성)
  + shift + f6 : 모든 변수 rename
  + 테스트 case들을 전체 다 돌리면 랜덤한 순서대로 실행된다.
  + 만약 findByName 에서 'spring'라는 회원을 넣고 save에도 'spring' 회원을 넣는 상황이라면 <br>이미 값이 repository 에 존재하여 오류가 발생한다.
  즉 메서드들이 순서에 의존하게 된다. <br>이런 테스트케이스는 좋은 테스트 케이스가 아니다. 독립적으로 실행될 수 있도록 설계해야한다.
  
  ### 회원 서비스 개발
  + validateDuplicateMember 메서드안의 memberRepository.findByName(member.getName()) 는 optional을 리턴한다.
  + 그러므로 Optional 참조변수를 굳이 만들지 않고 한번에 ifPresent()작업을 하여 클린코드를 만들 수 있다.
  + ctrl + alt + v : (커서가 있는 메서드의 리턴값)변수 추출하기.
  + ctrl + alt + shift+ t : 리팩토링 관련 옵션들(Rename, inline, extract 등등 다양함!)
  + ctrl + alt + m : 메서드 추출하기
  + service는 비즈니스에 조금더 의존해서 코드를 만드는 느낌이 있다.
  + 그에 반해 repository는 좀 더 개발적으로 매끄럽게 만든다.
  
  ### 회원 서비스 테스트
  + ctrl + shift + T : main()의 클래스위에 커서를 두고 누를시, 바로 패키지와 test class의 뼈대를 만들어 준다.
  + Test의 메서드명은 한글로 적어도 상관없다. 어차피 빌드나 최종 코딩에 포함되지 않기 때문이다.
  + Test는 given/when/then 패턴으로 구성하면 왠만해서는 끝낼 수 있다.
  + 리포지토리테스트와 마찬가지로 repository에 같은 값으로 인한 충돌을 막기 위해 @AfterEach 안에 clearStore()를 실행시킨다.
  + (beforeEach) 쓰기 전 상태 
    기존에는 회원 서비스와 서비스테스트 클래스들이 직접 메모리 회원 리포지토리를 생성하게 했다.
    1. MemberService의 repository와 MemberServiceTest의 repository가 지금 다른 인스턴스로 만들어 질 것이다.
    2. 지금은 static한 repository라 문제는 없다. 그러나 만약 static 하지 않으면 두개가 서로 다른 db를 생성한다.<br>
      (실제 클래스와 Test의 DB가 다르게 되는것이다)
  + 같은 인스턴스를 쓰게 하기 위해 회원 리포지토리의 코드가 회원 서비스 코드를 DI 가능하게 변경한다.
      (생성자 DI - MemberService의 생성자를 이용해 같은 DB를 의미하도록 설정하였다.)
  + Memberservice 입장에서 외부에서 repository를 넣어준다. 이런 개념을 dependency injection (di) 라고한다.
  + ctrl + click : 해당 클래스로 들어가기.(단축키)
  
## 스프링 빈과 의존관계
### 컴포넌트 스캔과 자동 의존관계 설정
  + 우리가 만든 Controller Service Repository 클래스를 연결해보자.
#### 회원 컨트롤러에 의존관계 추가
  1. @Controller로 인해 MemberController는 spring bean에 등록
  2. spring container가 만들어지면서 생성되며 생성자를 호출
  3. @Autowired로 spring이 memberService클래스를 spring container에 존재하는 memberService와 연결을 해주려함.
#### 오류 발생 & memberService가 스프링 빈으로 등록되어 있지 않다.
  + MemberService class는 순수한 자바코드이기때문에 spring이 인식하지 못한다
#### 스프링 빈을 등록하는 2가지 방법
#### 회원 스프링 빈 등록(컴포넌트 스캔)
  + @Service를 통해 spring이 올라올때,  MemberService class를 bean에 등록해주고 container와 연결 할수 있다.
  + @Repository : 마찬가지로 Repository 클래스를 bean에 등록하고 컨테이너에 올려준다.
#### 총과정
  1. @Autowired로 MemberController의 생성자에 (컨테이너안의)spring bean에 등록되어있는 memberservice 객체를 넣어줌.(dependency injection - spring이 작업)
  2. @Autowired로 Memberservice를 생성시, spring bean에 MemberService를 등록하면서 생성자를 호출(컨테이너의 memberRepository 객체가 들어감.)
  3. 결국 MemberController -MemberService -MemberRepository가 연결 (1, 2번은 서로 같은 말을 다르게 표현했다)
  + @Service, @Repository, @Controller 다  @Componet가 들어있어서 컴포넌트 방식.
  + @Componet의 범위 : 같은 패키지안의 패키지들끼리만 찾아서 사용가능하다. (hellospring 안까지)
  + 밖에 패키지와 연결하는 방법도 존재는 한다.
  
### 자바 코드로 직접 스프링 빈 등록하기
```java
  @Configuration
public class SpringConfig {
    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}
```
1. memberService가 bean에 들어가고 memberRepository가 bean에 들어간다.
(이 순간부터 @Service, @Repository 랑 개념이 다르지 않다)
2. bean에 있는 memberRepository 객체를 가져와서 MemberService 객체를 만든다
+ 우리는 생성자 주입을 사용했다.
+ 필드 주입 : 수정이 불가능하기 때문에 필요할때만 사용한다.
+ setter 주입 : setter 메서드가 Public 하게 존재해야한다. 그러므로 다른사람이 setter를 호출해서 값이 바뀔 수 있기 때문에 쓰지 않는다.
+ 우리는 db는 확정짓지않은 상황이므로, 자바로 직접 스프링 빈을 등록할 시 다른 코드 변경없이 간단하게 DB변경이 가능하다. 그러므로 이후 코드는 현재상태에서 진행된다.
  
## 회원 관리 예제 - 웹 MVC 개발
### 회원 웹 기능 - 홈 화면 추가
+ templates 에 home.html을 만든다.
+ HomeController 를 만든다. - "/" 은 시작 도메인을 의미한다.
+ 이전에 우리가 홈 화면 출력한 static한 값 index.html이 무시된다.
+ 즉, 컨트롤러가 정적 파일보다 우선순위가 높다.
### 회원 웹 기능 - 등록
  1. 회원 등록 폼 개발
  2. 회원 등록 컨트롤러

#### 회원 등록 폼 컨트롤러
+ MemberController.class에 @Getmapping과 내용을 추가해준다.
+ members 디렉토리와 creatememberForm.html을 추가해준다.
1. GetMapping 으로 /members/new주소에 들어감(조회에 주로사용)  
2. template에서 return 값(createMemberForm)을 찾음
#### 회원 등록 폼 HTML
3. new 주소에 html이 뿌려진다. 그리고 html의 <form>로 인해 값을 입력받을 수 있음(js) 
(이때 <input> 안 name = "name" 의 "name"이 key값이 된다.)
4. web에서 값("spring")을 입력함.
5. html method="post"방식으로, @PostMapping으로 간다.(form같은 곳에 넣어서 전달/데이터 등록에 주로사용)
(MemberController의 @PostMapping으로 간다.)
#### 회원 등록 컨트롤러
6. Memberform.class 생성하기(웹 등록 화면에서 데이터를 전달 받을 폼 객체를 하나 만든다.)
7. MemberController에 create 메서드를 호출된다.
8. html의 <input내의> key값("name")을 보고, Memberform의 name에 넣어준다. <br>
추가공부 : 사실 이부분이 이해가 안간다. 연결해주는 key를 어떻게 찾는건지;spring이 찾아주는건지;
9. 만들어진 Memberform 객체를 매개변수로 create메서드가 실행된다.
10. join 메서드가 실행되고 return값으로 다시 홈으로 돌아가게 만든다.
  
### 회원 웹 기능 - 조회
1. @GetMapping으로 주소이동
2. memberList.html(thymeleaf가 동작하는 html) 찾음
3. <thead>, <tbody>에 의해 목록이 생성된다.( 추가공부! )
4. ${}는 model의 value(List형식의 members)가 들어간다.
5. th:each로 루프가 돈다.(th 엔진)
6. members List에서 member 하나를 뽑고 id와 name을 뽑는다.
7. 그 결과로 랜더링한 모습은 web의 목록을 열고 소스를 열면 보인다.(<tr>,<th> 등등)
8. 현재는 자바 메모리 안에 있기 때문에, 자바 종료시 메모리도 종료하여 목록은 사라진다. 
9. 그러므로 우리는 파일이나 데이터베이스에 데이터를 넣을 것이다.
 
## 스프링 DB 접근 기술
### H2 데이터베이스 설치
  + 파일에 직접 접근하다보면 파일충돌이 일어날 수 있음
  + 이를 막기 위해 소켓으로 들어가도록 제공해주신 jDBC url 사용(jdbc:h2:tcp://localhost/~/test)
  + sql 코드의 generated by default as identitiy 는 db에 값이 들어오지 않으면 db가 알아서 값을 채워줌
  + H2에서 작업에서시 db web이랑 cmd 꼭 켜둬야 한다!!! <br>
  끄게 되면 다시 C:\Program Files (x86)\H2\bin 방문

h2.bat 파일 열어야함
#### 테이블 생성하기
  
### 순수 Jdbc
  + 예전(20년전) 방식이므로 어떻게 돌아가는지만 알자.
#### 환경설정
+ 라이브러리 추가 후에, 코끼리 눌러주어야 DB연동이 된다.
+ jdbc가 라이브러리가 있어야 Java가 db에 접근이 가능하다.
#### Jdbc 회원 리포지토리 구현
+ 너무 예전 방식이라 코드해석을 굳이 하지않으셨다.
```java
            conn = getConnection();
            pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);  
```
+ RETURN_GENERATED_KEYS : SQL에서 자동으로 Key 값을 발생시킨다.
+ DB 자원들은 쓰고 난 후 꼭 릴리즈 해주어야 한다.(커넥션을 끊어야 함)
+ 참고 : Spring은 DataSourceUtils 를 통해서 db를 가져온다. <br>
  그러므로 닫을때도 DataSourceUtils 를 통해 닫아야한다.
#### 스프링 설정 변경  
+ @Configuration 으로 설정한 것들도 spring bean으로 관리가 된다.
+ DataSource는 Spring boot가 데이터베이스 커넥션 정보를 바탕으로 생성하고, 스프링 빈으로 만들어 둔다.(DI가능)
+ 본문 코드의 수정없이 interface를 DB클래스로만 구현하고, config만 수정했는데 Java메모리에서 H2 DB로 변경시켰다.
+ 이를 Spring 컨테이너와 DI를 사용하여 다형성을 이루었다고 한다.
+ 객체지향의 성격을 이용하여, 오직 application에 조립이 필요한 부분만 수정해주면 <br>결과를 얻을수 있는 점이 spring의 큰 장점이다.
  
### 스프링 통합 테스트
+ DB를 연결한채, Spring boot Test를 해보자.
+ Test 이기 때문에 값 수정할 일이 없다. 그래서 필드 Injection을 했다.
+ 반복테스트, 테스트하는 메서드들간의 독립성을 가지게 하기위해 DB를 지우고 다시 만드는 과정이 필요하다.
+ 이전처럼 beforeEach(),afterEach()로 해도 되지만, 
+ @Transactional : 스프링에서는 DB에 쿼리를 넣고 다시 롤백을 하는 기능을 제공한다.<br>(Member Table에 data가 없다.)
+ 참고 : 다른 @Service나 @controller 등이 있으면 @Transactional가 사용되지 않는다.
+ @Commit을 사용하면 @Transactional이 있어도 db에 올릴수 있다.
+ 이러면 이전의 자바테스트가 필요없어보인다. 그러나 아래의 이유로 자바테스트가 더 좋은 테스트 설계를 만들 수 있다.
  1. 시간적인 이유
  2. 단위테스트로 한 경우 더욱 세부적인 테스트 가능
  
### 스프링 JdbcTemplate
+ 실무에서 많이 쓰는 라이브러리다.
+ Jdbc에서 반복 되는 코드를 줄이고 줄여놓은 라이브러리로, sql만 직접작성하면 된다.
+ save 메서드를 보면, insert문을 쓰는 것 대신에 <br>
  JdbcTemplate의 여러 객체들과 sql id, keycol, columnName으로 작성되었다.<br>
  document에 문법이 있으므로 참고해서 쓰자.(Jdbc template manual)
+ Jdcb 부터 이후까지는 스프링 통합Test를 만들었기 때문에 Web에서 검증할 필요없이 Test를 돌리면 된다.<br>
  이렇게 스프링 통합 테스트를 잘 설계하면 매우 편리하다.(실제 개발업에서도 60%는 Test 코드작성에 투자한다.)
  
### JPA 
+ (sql 조차도 생략!)
1. 여러 라이브러리나 스프링부트에 JPA를 설정한 후 
2. 도메인 객체에 JPA 엔티티 매핑을 해준다. (ORM : object relational mapping 기술을 사용)
  + @Entitiy : jpa가 관리하는 클래스/엔티티가 된다.
  + @Id @GeneratedValue(strategy = GenerationType.IDENTITY) <br>
  Identity : db에 값이 들어가면 쿼리에 값을 넣어주지 않아도 DB가 자동으로 id에 1,2,3을 넣어준다. 
  + 만약 DB와 객체 colName이 다를때 ex) 객체 : name , DB : username <br>
  @Column(name = "username")
3. JPA 회원 리포지토리 생성
  + JPA에서 만든 엔티티는 내부적으로 DataSource를 들고 통신한다.
  + 이를 사용하기 위해서는 Entitiymanager를 만들어야한다.
  + em.persist(member) : insert quert를 만들어서 DB에 넣어주고, ID까지 member에다 set 해준다.
  + em.find(Member.class, id); : id 식별자를 통해 DB 안쪽 값을 찾아준다.
  + createQuery 
    + ctrl + alt + N : inline variable 만들기.(단축키)
    + JPQL이라는 객체지향 쿼리를 사용 
    + table을 대상이 아닌 객체(member 엔티티)를 대상으로 쿼리를 날림.(그래서 select에 member가 들어감)
    + 이미 col끼리는 mapping이 되어있음.
  + pk기반 기술인 save와 findByID는 jpql을 작성하지 않고 작성 할 수 있다.
  + findAll과 findByName은 jpql이 작성해야하다.
  + 나중에 나올 jpa기술을 spring이 감싸는 spingjpa를 사용하면 findAll과 findByName도 jpql 작성하지 않아도 된다.
4. 서비스 계층에 트랜잭션 추가
  + JPA에서 데이터를 저장하거나 변경하는 작업에서는 <br>
  꼭 @Transactional 을 적어, Transaction에서 작업이 되도록 해야한다.
  + 그러므로 데이터를 저장하는 join메소드가 있는 MemberService객체에 @Transactional 적어두자.
5. JPA를 사용하도록 스프링 설정 변경
6. MemberServiceIntegrationTest 돌리기
  + 콘솔창에 잘보면 Hibernate 구현체가 작성한 query가 보인다.
  + 처음에는 좀 어려운데.. 충분히 좋고 생산성을 올려준다.
  
### 스프링 데이터 JPA
+ 구현마저 생략, 인터페이스만 만들면 됨
1. 스프링 데이터 JPA 회원 리포지토리
+ 인터페이스끼리는 상속개념이라 extends 가 들어감.
+ 인터페이스는 클래스와 다르게 다중상속이 가능.
+ JpaRepository가 자동으로 구현체를 만들고 Spring Bean에 등록해준다.
2. 스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경
+ 이전까지는 memberRepository()메서드로 memberRepository를 만들었다.
+ 그러나 스프링 데이터 JPA는 인터페이스를 보고 spring Bean을 자동으로 만들어서 프록시란 기술로 객체를 만든다.
+ 그 객체를 injection 하면 되므로 memberRepository인터페이스만 써놓는다.<br>
  (인터페이스 자료형에 훨씬 큰 인스턴스가 들어갈수 있으므로)
+ JpaRepository 에 ctrl + click 해보면 구현되어있는 다양한 메서드들을 확인 할수 있다.<br>
  (우리가 공통적으로 생각할 수 있는 메서드들이 전부다 구현되어 있다.)
+ 단점 : 비즈니스마다 공통적일수 없는 것이 있다.
  (객체가 다르다던가 - 주문서, 배달, 식당 등등 , 변수명도 다르다던가 등)
+ 이를 해결하기 위해 함수이름마다 어느정도 규칙이 존재한다.
+ 즉 인터페이스 이름만으로도 구현이 되는 혁신적인 생각인 것이다!
  
## AOP
### AOP가 필요한 상황
+ 참고1 : Detail 부터 배우려하지말고, 언제 왜 쓰는지 알려고 해보자.
+ 참고2 :처음 web이 만들어지자마자 메서드를 호출하면 클래스들이 로딩되느라 시간이 많이 걸린다.
+ 참고3 :그래서 실무에서는 이것저것 미리 호출해서 warm up 한다.
#### 시간 측정 AOP 등록
  문제상황 : 상사가 만약 1000개의 메서드의 호출시간을 초단위로 달라고 했다.<br>
  근데 갑자기 miliseconds로 해달라고 했다.( 이걸 어떻게 해결할까?)
  
  + 시간을 측정하는 로직( long start~, long finish 등등의 로직)
  + 핵심 관심 사항(save , findAll 메서드)
  + 1000개라면 모든 시간로직과 핵심로직이 섞인 코드를 뒤져가면서 1000번 코드 수정을 해야할 것이다.<br>
  ***너무 힘들다!!***
### AOP 적용
+ 시간 측정 로직을 한곳에 모으고 관리가 가능하다.
#### 시간 측정 AOP 등록
1. @Aspect : AOP라고 인식
2. spring Bean에서 관리할 수 있도록 @Component를 쓸 수 있다.
3. 이런 AOP는 정형화된 작업이 아니므로, @Component 대신 SpringConfig에 @Bean으로 처리하는게 좋다.<br>
  그런데 우리는 그냥 @Component로 작업함.(Bean쓰면 에러 발생)
```java
      @Bean
    public TimeTraceAop timeTraceAop(){
        return new TimeTraceAop();
    }
```
4. @Around : 공통 관심 사항을 어디에 저장할것인지를 타겟팅해준다. 문법이 존재하는데 쓰던것만 쓴다.<br>
  그러므로 메뉴얼만 잘 봐주자. 주로 패키지명을 적는데, 특정 디렉토리만 해줄수도 있다.
5. Web을 만들고 회원가입과 목록을 해보면, START와 END에 시간이 측정
+ joinpoint 에 많은 메소드들이 있는데, <br>
 main서비스의 메서드들이 호출될때 잠깐 intercept해서 joinpoint의 메소드들이 작동하는 그런 방식이다.
+ 즉 시간 로직에 변경이 필요할때, TimeTraceAop만 바꾸면 되는 것이다! 문제해결!
+ execution의 경로만 바꿔주면, 원하는 메서드에만 TimeTraceAop 적용도 가능하다.
+ AOP 적용후 프록시가 생성 된다. <br>
  프록시 작용법 : 가짜 spring Bean에 memberService를 만들어낸다.<br>
  그리고 가짜 spring bean안 memberService의 메서드들을 호출해낸다
+ MemberController 생성자에 "System.out.println("memberService = " + memberService.getClass());" 를 추가하면<br> 프록시 상태를 볼 수 있다.
